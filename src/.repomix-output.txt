This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where empty lines have been removed.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: **/*, .cursorrules, .cursor/rules/*, .clinerules, CLAUDE.md
- Files matching these patterns are excluded: .*.*, **/*.pbxproj, **/node_modules/**, **/dist/**, **/build/**, **/compile/**, **/*.spec.*, **/*.pyc, **/.env, **/.env.*, **/*.env, **/*.env.*, **/*.lock, **/*.lockb, **/package-lock.*, **/pnpm-lock.*, **/*.tsbuildinfo, **/certdata.txt
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Empty lines have been removed from all files
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
daemon/
  client.ts
  commands.ts
  index.ts
  ipc.ts
  lock.ts
  spawn.ts
  wrapper.js
mcpli-backup.ts
mcpli.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="daemon/client.ts">
import { isDaemonRunning, getDaemonInfo, updateLastAccess } from './lock.js';
import { sendIPCRequest, generateRequestId, testIPCConnection } from './ipc.js';
import { startDaemon, DaemonOptions } from './spawn.js';
export interface DaemonClientOptions extends DaemonOptions {
  autoStart?: boolean;
  fallbackToStateless?: boolean;
}
export class DaemonClient {
  constructor(
    private command: string,
    private args: string[],
    private options: DaemonClientOptions = {}
  ) {
    this.options = {
      autoStart: true,
      fallbackToStateless: true,
      ...options
    };
  }
  async listTools(): Promise<any> {
    try {
      const result = await this.callDaemon('listTools');
      return result;
    } catch (error) {
      if (this.options.fallbackToStateless) {
        if (this.options.debug) {
          console.error('[DEBUG] Daemon listTools failed, falling back to stateless:', error);
        }
        return this.fallbackListTools();
      }
      throw error;
    }
  }
  async callTool(params: { name: string; arguments: any }): Promise<any> {
    try {
      const result = await this.callDaemon('callTool', params);
      return result;
    } catch (error) {
      if (this.options.fallbackToStateless) {
        if (this.options.debug) {
          console.error('[DEBUG] Daemon callTool failed, falling back to stateless:', error);
        }
        return this.fallbackCallTool(params);
      }
      throw error;
    }
  }
  private async callDaemon(method: string, params?: any): Promise<any> {
    const cwd = this.options.cwd || process.cwd();
    // Check if daemon is running
    const isRunning = await isDaemonRunning(cwd);
    if (!isRunning) {
      if (this.options.autoStart && this.command) {
        if (this.options.debug) {
          console.error('[DEBUG] Starting daemon automatically');
        }
        await this.startDaemon();
      } else {
        throw new Error(this.command ? 'Daemon not running and auto-start disabled' : 'No daemon running and no server command provided');
      }
    }
    // Get daemon info
    const daemonInfo = await getDaemonInfo(cwd);
    if (!daemonInfo) {
      throw new Error('Daemon info not available');
    }
    // Test connection
    if (!(await testIPCConnection(daemonInfo))) {
      throw new Error('Cannot connect to daemon IPC socket');
    }
    // Send request
    const request = {
      id: generateRequestId(),
      method: method as 'listTools' | 'callTool' | 'ping',
      params
    };
    const result = await sendIPCRequest(daemonInfo.socket, request);
    // Update last access time
    await updateLastAccess(cwd);
    return result;
  }
  private async startDaemon(): Promise<void> {
    try {
      const daemon = await startDaemon(this.command, this.args, this.options);
      // Wait a moment for daemon to be fully ready
      await new Promise(resolve => setTimeout(resolve, 100));
      if (this.options.debug) {
        console.error('[DEBUG] Daemon started successfully');
      }
    } catch (error) {
      if (this.options.debug) {
        console.error('[DEBUG] Failed to start daemon:', error);
      }
      throw new Error(`Failed to start daemon: ${error instanceof Error ? error.message : error}`);
    }
  }
  private async fallbackListTools(): Promise<any> {
    const { Client } = await import('@modelcontextprotocol/sdk/client/index.js');
    const { StdioClientTransport } = await import('@modelcontextprotocol/sdk/client/stdio.js');
    const transport = new StdioClientTransport({
      command: this.command,
      args: this.args,
      stderr: this.options.logs ? 'inherit' : 'ignore'
    });
    const client = new Client({
      name: 'mcpli',
      version: '1.0.0'
    }, {
      capabilities: {}
    });
    try {
      await client.connect(transport);
      const result = await client.listTools();
      await client.close();
      return result;
    } catch (error) {
      await client.close();
      throw error;
    }
  }
  private async fallbackCallTool(params: { name: string; arguments: any }): Promise<any> {
    const { Client } = await import('@modelcontextprotocol/sdk/client/index.js');
    const { StdioClientTransport } = await import('@modelcontextprotocol/sdk/client/stdio.js');
    const transport = new StdioClientTransport({
      command: this.command,
      args: this.args,
      stderr: this.options.logs ? 'inherit' : 'ignore'
    });
    const client = new Client({
      name: 'mcpli',
      version: '1.0.0'
    }, {
      capabilities: {}
    });
    try {
      await client.connect(transport);
      const result = await client.callTool(params);
      await client.close();
      return result;
    } catch (error) {
      await client.close();
      throw error;
    }
  }
  async ping(): Promise<boolean> {
    try {
      const result = await this.callDaemon('ping');
      return result === 'pong';
    } catch {
      return false;
    }
  }
}
// Convenience function for one-off operations
export async function withDaemonClient<T>(
  command: string,
  args: string[],
  options: DaemonClientOptions,
  operation: (client: DaemonClient) => Promise<T>
): Promise<T> {
  const client = new DaemonClient(command, args, options);
  return await operation(client);
}
</file>

<file path="daemon/commands.ts">
import { 
  isDaemonRunning, 
  getDaemonInfo, 
  stopDaemon, 
  cleanupStaleLock 
} from './lock.js';
import { startDaemon, DaemonOptions } from './spawn.js';
import { testIPCConnection } from './ipc.js';
import fs from 'fs/promises';
import path from 'path';
export interface DaemonCommandOptions extends DaemonOptions {
  force?: boolean;
}
export async function handleDaemonStart(
  command: string, 
  args: string[], 
  options: DaemonCommandOptions = {}
): Promise<void> {
  const cwd = options.cwd || process.cwd();
  // Check if daemon is already running
  if (await isDaemonRunning(cwd)) {
    const info = await getDaemonInfo(cwd);
    console.log(`Daemon is already running (PID ${info?.pid})`);
    return;
  }
  try {
    console.log(`Starting daemon: ${command} ${args.join(' ')}`);
    const daemon = await startDaemon(command, args, options);
    console.log(`Daemon started successfully (PID ${daemon.lock.info.pid})`);
    console.log(`Socket: ${daemon.lock.info.socket}`);
    if (options.debug) {
      console.log('Debug mode enabled - daemon will log to console');
    }
  } catch (error) {
    console.error(`Failed to start daemon: ${error instanceof Error ? error.message : error}`);
    process.exit(1);
  }
}
export async function handleDaemonStop(options: DaemonCommandOptions = {}): Promise<void> {
  const cwd = options.cwd || process.cwd();
  if (!(await isDaemonRunning(cwd))) {
    console.log('No daemon is running');
    return;
  }
  const info = await getDaemonInfo(cwd);
  if (!info) {
    console.log('No daemon information found');
    await cleanupStaleLock(cwd);
    return;
  }
  try {
    console.log(`Stopping daemon (PID ${info.pid})...`);
    const stopped = await stopDaemon(cwd, options.force);
    if (stopped) {
      console.log('Daemon stopped successfully');
    } else {
      console.log('Daemon may have already been stopped');
    }
  } catch (error) {
    console.error(`Failed to stop daemon: ${error instanceof Error ? error.message : error}`);
    process.exit(1);
  }
}
export async function handleDaemonStatus(options: DaemonCommandOptions = {}): Promise<void> {
  const cwd = options.cwd || process.cwd();
  const info = await getDaemonInfo(cwd);
  if (!info) {
    console.log('Status: Not running');
    return;
  }
  const isRunning = await isDaemonRunning(cwd);
  if (!isRunning) {
    console.log('Status: Not running (stale lock file cleaned up)');
    return;
  }
  // Test IPC connection
  const canConnect = await testIPCConnection(info);
  console.log('Status: Running');
  console.log(`PID: ${info.pid}`);
  console.log(`Command: ${info.command} ${info.args.join(' ')}`);
  console.log(`Started: ${new Date(info.started).toLocaleString()}`);
  console.log(`Last access: ${new Date(info.lastAccess).toLocaleString()}`);
  console.log(`Socket: ${info.socket}`);
  console.log(`IPC connection: ${canConnect ? 'OK' : 'FAILED'}`);
  console.log(`Working directory: ${info.cwd}`);
  // Calculate uptime
  const uptimeMs = Date.now() - new Date(info.started).getTime();
  const uptimeMinutes = Math.floor(uptimeMs / 60000);
  const uptimeHours = Math.floor(uptimeMinutes / 60);
  const uptimeDays = Math.floor(uptimeHours / 24);
  let uptimeStr = '';
  if (uptimeDays > 0) uptimeStr += `${uptimeDays}d `;
  if (uptimeHours > 0) uptimeStr += `${uptimeHours % 24}h `;
  uptimeStr += `${uptimeMinutes % 60}m`;
  console.log(`Uptime: ${uptimeStr}`);
  // Calculate idle time
  const idleMs = Date.now() - new Date(info.lastAccess).getTime();
  const idleMinutes = Math.floor(idleMs / 60000);
  const idleHours = Math.floor(idleMinutes / 60);
  let idleStr = '';
  if (idleHours > 0) idleStr += `${idleHours}h `;
  idleStr += `${idleMinutes % 60}m`;
  console.log(`Idle time: ${idleStr}`);
}
export async function handleDaemonRestart(
  command: string,
  args: string[],
  options: DaemonCommandOptions = {}
): Promise<void> {
  console.log('Restarting daemon...');
  // Stop existing daemon
  await handleDaemonStop(options);
  // Wait a moment for cleanup
  await new Promise(resolve => setTimeout(resolve, 500));
  // Start new daemon
  await handleDaemonStart(command, args, options);
}
export async function handleDaemonLogs(options: DaemonCommandOptions = {}): Promise<void> {
  const cwd = options.cwd || process.cwd();
  const logPath = path.join(cwd, '.mcpli', 'daemon.log');
  try {
    const logContent = await fs.readFile(logPath, 'utf8');
    console.log(logContent);
  } catch (error) {
    if ((error as any).code === 'ENOENT') {
      console.log('No log file found. Daemon may not have been started with --logs flag.');
    } else {
      console.error(`Failed to read log file: ${error instanceof Error ? error.message : error}`);
    }
  }
}
export async function handleDaemonClean(options: DaemonCommandOptions = {}): Promise<void> {
  const cwd = options.cwd || process.cwd();
  const mcpliDir = path.join(cwd, '.mcpli');
  try {
    // Stop daemon if running
    if (await isDaemonRunning(cwd)) {
      console.log('Stopping running daemon...');
      await stopDaemon(cwd, true); // Force stop
    }
    // Clean up all daemon files
    const files = [
      'daemon.lock',
      'daemon.sock',
      'daemon.log',
      'daemon.config.json'
    ];
    let cleaned = 0;
    for (const file of files) {
      try {
        await fs.unlink(path.join(mcpliDir, file));
        cleaned++;
      } catch {
        // File doesn't exist, which is fine
      }
    }
    console.log(`Cleaned up ${cleaned} daemon files`);
    // Remove .mcpli directory if empty
    try {
      await fs.rmdir(mcpliDir);
      console.log('Removed empty .mcpli directory');
    } catch {
      // Directory not empty or doesn't exist
    }
  } catch (error) {
    console.error(`Failed to clean daemon files: ${error instanceof Error ? error.message : error}`);
    process.exit(1);
  }
}
export function printDaemonHelp(): void {
  console.log('MCPLI Daemon Management');
  console.log('');
  console.log('Usage:');
  console.log('  mcpli daemon <command> [options]');
  console.log('');
  console.log('Commands:');
  console.log('  start [-- command args...]  Start daemon with MCP server command');
  console.log('  stop                         Stop running daemon');
  console.log('  restart [-- command args...] Restart daemon');
  console.log('  status                       Show daemon status and info');
  console.log('  logs                         Show daemon log output');
  console.log('  clean                        Clean up all daemon files');
  console.log('');
  console.log('Options:');
  console.log('  --force                      Force stop daemon');
  console.log('  --logs                       Enable daemon logging');
  console.log('  --debug                      Enable debug output');
  console.log('  --timeout <ms>               Set daemon inactivity timeout');
  console.log('');
  console.log('Examples:');
  console.log('  mcpli daemon start -- node server.js');
  console.log('  mcpli daemon status');
  console.log('  mcpli daemon stop');
  console.log('  mcpli daemon clean');
}
</file>

<file path="daemon/index.ts">
// Daemon management exports
export * from './lock.js';
export * from './ipc.js';
export * from './spawn.js';
export * from './client.js';
export * from './commands.js';
</file>

<file path="daemon/ipc.ts">
import net from 'net';
import path from 'path';
import { DaemonInfo } from './lock.js';
export interface IPCRequest {
  id: string;
  method: 'listTools' | 'callTool' | 'ping';
  params?: any;
}
export interface IPCResponse {
  id: string;
  result?: any;
  error?: string;
}
export interface IPCServer {
  server: net.Server;
  close: () => Promise<void>;
}
export async function createIPCServer(
  socketPath: string,
  handler: (request: IPCRequest) => Promise<any>
): Promise<IPCServer> {
  // Remove existing socket file if it exists
  try {
    await import('fs/promises').then(fs => fs.unlink(socketPath));
  } catch {
    // Socket file doesn't exist, which is fine
  }
  const server = net.createServer((client) => {
    let buffer = '';
    client.on('data', async (data) => {
      buffer += data.toString();
      // Handle multiple JSON messages in buffer
      while (true) {
        const newlineIndex = buffer.indexOf('\n');
        if (newlineIndex === -1) break;
        const message = buffer.slice(0, newlineIndex);
        buffer = buffer.slice(newlineIndex + 1);
        if (!message.trim()) continue;
        try {
          const request: IPCRequest = JSON.parse(message);
          const result = await handler(request);
          const response: IPCResponse = { id: request.id, result };
          client.write(JSON.stringify(response) + '\n');
        } catch (error) {
          const response: IPCResponse = {
            id: 'unknown',
            error: error instanceof Error ? error.message : String(error)
          };
          client.write(JSON.stringify(response) + '\n');
        }
      }
    });
    client.on('error', (error) => {
      console.error('IPC client error:', error);
    });
  });
  return new Promise((resolve, reject) => {
    server.listen(socketPath, () => {
      resolve({
        server,
        close: () => new Promise((resolve) => {
          server.close(() => {
            // Clean up socket file
            import('fs/promises').then(fs => 
              fs.unlink(socketPath).catch(() => {})
            ).finally(resolve);
          });
        })
      });
    });
    server.on('error', reject);
  });
}
export async function sendIPCRequest(
  socketPath: string,
  request: IPCRequest,
  timeoutMs = 10000
): Promise<any> {
  return new Promise((resolve, reject) => {
    const client = net.connect(socketPath, () => {
      client.write(JSON.stringify(request) + '\n');
    });
    let buffer = '';
    const timeout = setTimeout(() => {
      client.destroy();
      reject(new Error(`IPC request timeout after ${timeoutMs}ms`));
    }, timeoutMs);
    client.on('data', (data) => {
      buffer += data.toString();
      const newlineIndex = buffer.indexOf('\n');
      if (newlineIndex !== -1) {
        const message = buffer.slice(0, newlineIndex);
        clearTimeout(timeout);
        client.end();
        try {
          const response: IPCResponse = JSON.parse(message);
          if (response.error) {
            reject(new Error(response.error));
          } else {
            resolve(response.result);
          }
        } catch (error) {
          reject(new Error(`Invalid IPC response: ${error}`));
        }
      }
    });
    client.on('error', (error) => {
      clearTimeout(timeout);
      reject(error);
    });
    client.on('timeout', () => {
      clearTimeout(timeout);
      client.destroy();
      reject(new Error('IPC connection timeout'));
    });
  });
}
export async function testIPCConnection(daemonInfo: DaemonInfo): Promise<boolean> {
  try {
    const request: IPCRequest = {
      id: Date.now().toString(),
      method: 'ping'
    };
    await sendIPCRequest(daemonInfo.socket, request, 2000);
    return true;
  } catch {
    return false;
  }
}
export function generateRequestId(): string {
  return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
}
</file>

<file path="daemon/lock.ts">
import { lock, unlock } from 'proper-lockfile';
import fs from 'fs/promises';
import path from 'path';
import { existsSync } from 'fs';
export interface DaemonInfo {
  pid: number;
  socket: string;
  command: string;
  args: string[];
  started: string;
  lastAccess: string;
  cwd: string;
}
export interface DaemonLock {
  info: DaemonInfo;
  release: () => Promise<void>;
}
const MCPLI_DIR = '.mcpli';
const LOCK_FILE = 'daemon.lock';
function getMcpliDir(cwd = process.cwd()): string {
  return path.join(cwd, MCPLI_DIR);
}
function getLockPath(cwd = process.cwd()): string {
  return path.join(getMcpliDir(cwd), LOCK_FILE);
}
async function ensureMcpliDir(cwd = process.cwd()): Promise<void> {
  const mcpliDir = getMcpliDir(cwd);
  if (!existsSync(mcpliDir)) {
    await fs.mkdir(mcpliDir, { recursive: true });
  }
}
export async function acquireDaemonLock(
  command: string,
  args: string[],
  cwd = process.cwd()
): Promise<DaemonLock> {
  await ensureMcpliDir(cwd);
  const lockPath = getLockPath(cwd);
  // Create empty lock file if it doesn't exist
  try {
    await fs.access(lockPath);
  } catch {
    await fs.writeFile(lockPath, '{}');
  }
  try {
    // Acquire exclusive lock - will throw if already locked
    const release = await lock(lockPath, { 
      retries: 0,
      stale: 60000 // Consider lock stale after 1 minute
    });
    const daemonInfo: DaemonInfo = {
      pid: process.pid,
      socket: path.join(getMcpliDir(cwd), 'daemon.sock'),
      command,
      args,
      started: new Date().toISOString(),
      lastAccess: new Date().toISOString(),
      cwd
    };
    // Write daemon info to the lock file
    await fs.writeFile(lockPath, JSON.stringify(daemonInfo, null, 2));
    return {
      info: daemonInfo,
      release: async () => {
        try {
          await fs.unlink(lockPath);
        } catch {
          // File might already be deleted
        }
        await release();
      }
    };
  } catch (error) {
    throw new Error(`Cannot acquire daemon lock: ${error instanceof Error ? error.message : error}`);
  }
}
export async function getDaemonInfo(cwd = process.cwd()): Promise<DaemonInfo | null> {
  try {
    const lockPath = getLockPath(cwd);
    const data = await fs.readFile(lockPath, 'utf8');
    return JSON.parse(data);
  } catch {
    return null;
  }
}
export async function updateLastAccess(cwd = process.cwd()): Promise<void> {
  const info = await getDaemonInfo(cwd);
  if (!info) return;
  info.lastAccess = new Date().toISOString();
  const lockPath = getLockPath(cwd);
  try {
    await fs.writeFile(lockPath, JSON.stringify(info, null, 2));
  } catch {
    // Ignore write errors - daemon might be shutting down
  }
}
export async function isDaemonRunning(cwd = process.cwd()): Promise<boolean> {
  const info = await getDaemonInfo(cwd);
  if (!info) return false;
  try {
    // Send test signal - throws if process doesn't exist
    process.kill(info.pid, 0);
    return true;
  } catch {
    // Process not running, clean up stale lock
    await cleanupStaleLock(cwd);
    return false;
  }
}
export async function cleanupStaleLock(cwd = process.cwd()): Promise<void> {
  try {
    const lockPath = getLockPath(cwd);
    await fs.unlink(lockPath);
  } catch {
    // Lock file might not exist or already cleaned up
  }
}
export async function stopDaemon(cwd = process.cwd(), force = false): Promise<boolean> {
  const info = await getDaemonInfo(cwd);
  if (!info) return false;
  try {
    // Send termination signal
    process.kill(info.pid, force ? 'SIGKILL' : 'SIGTERM');
    // Wait for graceful shutdown
    if (!force) {
      // Wait up to 5 seconds for graceful shutdown
      for (let i = 0; i < 50; i++) {
        try {
          process.kill(info.pid, 0);
          await new Promise(resolve => setTimeout(resolve, 100));
        } catch {
          // Process has exited
          break;
        }
      }
      // Force kill if still running
      try {
        process.kill(info.pid, 0);
        process.kill(info.pid, 'SIGKILL');
      } catch {
        // Already exited
      }
    }
    // Clean up lock file
    await cleanupStaleLock(cwd);
    return true;
  } catch {
    // Process might already be dead
    await cleanupStaleLock(cwd);
    return false;
  }
}
</file>

<file path="daemon/spawn.ts">
import { spawn, ChildProcess } from 'child_process';
import path from 'path';
import { fileURLToPath } from 'url';
import { DaemonLock } from './lock.js';
import { createIPCServer, IPCRequest } from './ipc.js';
import { Client } from '@modelcontextprotocol/sdk/client/index.js';
import { StdioClientTransport } from '@modelcontextprotocol/sdk/client/stdio.js';
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
export interface DaemonOptions {
  logs?: boolean;
  debug?: boolean;
  cwd?: string;
  timeout?: number;
}
export interface DaemonProcess {
  lock: DaemonLock;
  close: () => Promise<void>;
}
export async function startDaemon(
  command: string,
  args: string[],
  options: DaemonOptions = {}
): Promise<DaemonProcess> {
  const cwd = options.cwd || process.cwd();
  // Create socket path in .mcpli directory
  const mcpliDir = path.join(cwd, '.mcpli');
  const socketPath = path.join(mcpliDir, 'daemon.sock');
  // Ensure .mcpli directory exists
  const fs = await import('fs/promises');
  const { existsSync } = await import('fs');
  if (!existsSync(mcpliDir)) {
    await fs.mkdir(mcpliDir, { recursive: true });
  }
  // Create wrapper script path
  const wrapperPath = path.join(__dirname, 'wrapper.js');
  // Spawn the daemon wrapper process as truly detached
  const daemon = spawn('node', [wrapperPath], {
    detached: true,
    stdio: 'ignore', // Completely detach from parent
    cwd,
    env: {
      ...process.env,
      MCPLI_SOCKET_PATH: socketPath,
      MCPLI_CWD: cwd,
      MCPLI_DEBUG: options.debug ? '1' : '0',
      MCPLI_TIMEOUT: (options.timeout || 30 * 60 * 1000).toString(),
      MCPLI_LOGS: options.logs ? '1' : '0',
      MCPLI_COMMAND: command,
      MCPLI_ARGS: JSON.stringify(args)
    }
  });
  // Allow parent to exit independently - this is crucial
  daemon.unref();
  // Wait for daemon to be ready
  await waitForDaemonReady(socketPath, 10000);
  // Get the lock info from the daemon
  const { getDaemonInfo } = await import('./lock.js');
  const lock = await getDaemonInfo(cwd);
  if (!lock) {
    throw new Error('Failed to get daemon lock info after startup');
  }
  return {
    lock: {
      info: lock,
      release: async () => {
        // Lock is now owned by daemon - don't release here
      }
    },
    close: async () => {
      try {
        if (daemon.pid) {
          process.kill(daemon.pid, 'SIGTERM');
          // Wait for graceful shutdown
          await new Promise(resolve => {
            const timeout = setTimeout(resolve, 5000);
            daemon.on('exit', () => {
              clearTimeout(timeout);
              resolve(undefined);
            });
          });
          // Force kill if still running
          try {
            if (daemon.pid) {
              process.kill(daemon.pid, 'SIGKILL');
            }
          } catch {
            // Already dead
          }
        }
      } catch {
        // Process might already be dead
      }
    }
  };
}
async function waitForDaemonReady(socketPath: string, timeoutMs: number): Promise<void> {
  const start = Date.now();
  while (Date.now() - start < timeoutMs) {
    try {
      const { sendIPCRequest, generateRequestId } = await import('./ipc.js');
      await sendIPCRequest(socketPath, {
        id: generateRequestId(),
        method: 'ping'
      }, 1000);
      return;
    } catch {
      await new Promise(resolve => setTimeout(resolve, 100));
    }
  }
  throw new Error(`Daemon failed to start within ${timeoutMs}ms`);
}
// In-process daemon for development/testing
export class InProcessDaemon {
  private mcpClient?: Client;
  private ipcServer?: any;
  public lock?: DaemonLock;
  private inactivityTimeout?: NodeJS.Timeout;
  constructor(
    private command: string,
    private args: string[],
    private options: DaemonOptions = {}
  ) {}
  async start(): Promise<void> {
    const cwd = this.options.cwd || process.cwd();
    // Acquire lock
    const { acquireDaemonLock } = await import('./lock.js');
    this.lock = await acquireDaemonLock(this.command, this.args, cwd);
    // Start MCP client
    const transport = new StdioClientTransport({
      command: this.command,
      args: this.args,
      stderr: this.options.logs ? 'inherit' : 'ignore'
    });
    this.mcpClient = new Client({
      name: 'mcpli-daemon',
      version: '1.0.0'
    }, {
      capabilities: {}
    });
    await this.mcpClient.connect(transport);
    // Start IPC server
    this.ipcServer = await createIPCServer(
      this.lock!.info.socket,
      this.handleIPCRequest.bind(this)
    );
    // Set up inactivity timeout
    this.resetInactivityTimer();
    // Set up cleanup handlers
    process.on('SIGTERM', this.gracefulShutdown.bind(this));
    process.on('SIGINT', this.gracefulShutdown.bind(this));
  }
  private async handleIPCRequest(request: IPCRequest): Promise<any> {
    this.resetInactivityTimer();
    switch (request.method) {
      case 'ping':
        return 'pong';
      case 'listTools':
        if (!this.mcpClient) throw new Error('MCP client not connected');
        const result = await this.mcpClient.listTools();
        return result;
      case 'callTool':
        if (!this.mcpClient) throw new Error('MCP client not connected');
        return await this.mcpClient.callTool(request.params);
      default:
        throw new Error(`Unknown method: ${request.method}`);
    }
  }
  private resetInactivityTimer(): void {
    if (this.inactivityTimeout) {
      clearTimeout(this.inactivityTimeout);
    }
    const timeoutMs = this.options.timeout || 30 * 60 * 1000; // 30 minutes
    this.inactivityTimeout = setTimeout(() => {
      this.gracefulShutdown();
    }, timeoutMs);
  }
  private async gracefulShutdown(): Promise<void> {
    if (this.options.debug) {
      console.error('[DEBUG] Daemon shutting down gracefully');
    }
    // Clear timeout
    if (this.inactivityTimeout) {
      clearTimeout(this.inactivityTimeout);
    }
    // Close IPC server
    if (this.ipcServer) {
      await this.ipcServer.close();
    }
    // Close MCP client
    if (this.mcpClient) {
      await this.mcpClient.close();
    }
    // Release lock
    if (this.lock) {
      await this.lock.release();
    }
    process.exit(0);
  }
  async close(): Promise<void> {
    await this.gracefulShutdown();
  }
}
</file>

<file path="daemon/wrapper.js">
#!/usr/bin/env node
/**
 * MCPLI Daemon Wrapper - Long-lived MCP server process
 * 
 * This script runs as a detached daemon process and manages
 * a connection to an MCP server while providing IPC interface
 * for MCPLI commands.
 */
import { createIPCServer } from './ipc.js';
import { Client } from '@modelcontextprotocol/sdk/client/index.js';
import { StdioClientTransport } from '@modelcontextprotocol/sdk/client/stdio.js';
import { acquireDaemonLock } from './lock.js';
class MCPLIDaemon {
  constructor() {
    this.mcpClient = null;
    this.ipcServer = null;
    this.inactivityTimeout = null;
    this.isShuttingDown = false;
    this.daemonLock = null;
    // Read environment variables
    this.socketPath = process.env.MCPLI_SOCKET_PATH;
    this.cwd = process.env.MCPLI_CWD || process.cwd();
    this.debug = process.env.MCPLI_DEBUG === '1';
    this.logs = process.env.MCPLI_LOGS === '1';
    this.timeoutMs = parseInt(process.env.MCPLI_TIMEOUT || '1800000', 10); // 30 minutes
    this.mcpCommand = process.env.MCPLI_COMMAND;
    this.mcpArgs = JSON.parse(process.env.MCPLI_ARGS || '[]');
    if (!this.socketPath || !this.mcpCommand) {
      console.error('Missing required environment variables or arguments');
      process.exit(1);
    }
  }
  async start() {
    try {
      if (this.debug) {
        console.error(`[DAEMON] Starting with command: ${this.mcpCommand} ${this.mcpArgs.join(' ')}`);
        console.error(`[DAEMON] Socket path: ${this.socketPath}`);
      }
      // Acquire daemon lock - this writes the correct PID (our PID)
      this.daemonLock = await acquireDaemonLock(this.mcpCommand, this.mcpArgs, this.cwd);
      if (this.debug) {
        console.error(`[DAEMON] Lock acquired for PID ${this.daemonLock.info.pid}`);
      }
      // Start MCP client
      await this.startMCPClient();
      // Start IPC server
      await this.startIPCServer();
      // Set up cleanup handlers
      process.on('SIGTERM', this.gracefulShutdown.bind(this));
      process.on('SIGINT', this.gracefulShutdown.bind(this));
      process.on('uncaughtException', this.handleError.bind(this));
      process.on('unhandledRejection', this.handleError.bind(this));
      // Start inactivity timer
      this.resetInactivityTimer();
      if (this.debug) {
        console.error('[DAEMON] Started successfully');
      }
    } catch (error) {
      console.error('[DAEMON] Failed to start:', error);
      process.exit(1);
    }
  }
  async startMCPClient() {
    const transport = new StdioClientTransport({
      command: this.mcpCommand,
      args: this.mcpArgs,
      stderr: (this.debug || this.logs) ? 'inherit' : 'ignore'
    });
    this.mcpClient = new Client({
      name: 'mcpli-daemon',
      version: '1.0.0'
    }, {
      capabilities: {}
    });
    await this.mcpClient.connect(transport);
    if (this.debug) {
      console.error('[DAEMON] MCP client connected');
    }
  }
  async startIPCServer() {
    this.ipcServer = await createIPCServer(
      this.socketPath,
      this.handleIPCRequest.bind(this)
    );
    if (this.debug) {
      console.error('[DAEMON] IPC server listening on:', this.socketPath);
    }
  }
  async handleIPCRequest(request) {
    this.resetInactivityTimer();
    if (this.debug) {
      console.error(`[DAEMON] Handling IPC request: ${request.method}`);
    }
    switch (request.method) {
      case 'ping':
        return 'pong';
      case 'listTools':
        if (!this.mcpClient) throw new Error('MCP client not connected');
        const result = await this.mcpClient.listTools();
        return result;
      case 'callTool':
        if (!this.mcpClient) throw new Error('MCP client not connected');
        return await this.mcpClient.callTool(request.params);
      default:
        throw new Error(`Unknown method: ${request.method}`);
    }
  }
  resetInactivityTimer() {
    if (this.inactivityTimeout) {
      clearTimeout(this.inactivityTimeout);
    }
    this.inactivityTimeout = setTimeout(() => {
      if (this.debug) {
        console.error('[DAEMON] Shutting down due to inactivity');
      }
      this.gracefulShutdown();
    }, this.timeoutMs);
  }
  async gracefulShutdown() {
    if (this.isShuttingDown) return;
    this.isShuttingDown = true;
    if (this.debug) {
      console.error('[DAEMON] Starting graceful shutdown');
    }
    // Clear inactivity timer
    if (this.inactivityTimeout) {
      clearTimeout(this.inactivityTimeout);
    }
    try {
      // Close IPC server
      if (this.ipcServer) {
        await this.ipcServer.close();
        if (this.debug) {
          console.error('[DAEMON] IPC server closed');
        }
      }
      // Close MCP client
      if (this.mcpClient) {
        await this.mcpClient.close();
        if (this.debug) {
          console.error('[DAEMON] MCP client closed');
        }
      }
    } catch (error) {
      console.error('[DAEMON] Error during shutdown:', error);
    }
    // Release the daemon lock
    if (this.daemonLock) {
      await this.daemonLock.release();
      if (this.debug) {
        console.error('[DAEMON] Lock released');
      }
    }
    if (this.debug) {
      console.error('[DAEMON] Shutdown complete');
    }
    process.exit(0);
  }
  handleError(error) {
    console.error('[DAEMON] Unhandled error:', error);
    this.gracefulShutdown();
  }
}
// Start the daemon
const daemon = new MCPLIDaemon();
daemon.start().catch(error => {
  console.error('[DAEMON] Fatal error:', error);
  process.exit(1);
});
</file>

<file path="mcpli-backup.ts">
#!/usr/bin/env node
/**
 * MCPLI - Turn any MCP server into a first-class CLI tool
 * 
 * This is a minimal working version to demonstrate the core concept.
 */
import { Client } from '@modelcontextprotocol/sdk/client/index.js';
import { StdioClientTransport } from '@modelcontextprotocol/sdk/client/stdio.js';
interface GlobalOptions {
  help?: boolean;
  quiet?: boolean;
  raw?: boolean;
  debug?: boolean;
  timeout?: number;
}
function parseArgs(argv: string[]) {
  const args = argv.slice(2); // Remove node and script name
  const globals: GlobalOptions = { timeout: 30000 };
  // Find the -- separator
  const dashIndex = args.indexOf('--');
  if (dashIndex === -1) {
    console.error('Error: Child command required after --');
    console.error('Usage: mcpli [options] [tool] [params...] -- <command> [args...]');
    process.exit(1);
  }
  const childCommand = args[dashIndex + 1];
  const childArgs = args.slice(dashIndex + 2);
  const userArgs = args.slice(0, dashIndex);
  if (!childCommand) {
    console.error('Error: Child command required after --');
    process.exit(1);
  }
  // Parse global options
  for (const arg of userArgs) {
    if (arg === '--help' || arg === '-h') globals.help = true;
    else if (arg === '--quiet' || arg === '-q') globals.quiet = true;
    else if (arg === '--raw') globals.raw = true;
    else if (arg === '--debug') globals.debug = true;
  }
  return { globals, childCommand, childArgs, userArgs };
}
async function discoverTools(command: string, args: string[], options: GlobalOptions) {
  const transport = new StdioClientTransport({
    command,
    args,
    stderr: options.quiet ? 'ignore' : 'inherit'
  });
  const client = new Client({
    name: 'mcpli',
    version: '1.0.0'
  }, {
    capabilities: {}
  });
  try {
    await client.connect(transport);
    const result = await client.listTools();
    return { tools: result.tools || [], client, close: () => client.close() };
  } catch (error) {
    throw new Error(`Failed to connect to MCP server: ${error instanceof Error ? error.message : error}`);
  }
}
function normalizeToolName(name: string): string {
  return name.toLowerCase().replace(/[^a-z0-9]/g, '');
}
function findTool(userArgs: string[], tools: any[]) {
  const toolMap = new Map();
  // Build tool index
  for (const tool of tools) {
    const name = tool.name;
    toolMap.set(name, tool);
    toolMap.set(name.replace(/_/g, '-'), tool);
    toolMap.set(normalizeToolName(name), tool);
  }
  // Look for tool selection
  for (const arg of userArgs) {
    if (arg.startsWith('--')) {
      const toolName = arg.slice(2);
      if (toolMap.has(toolName)) {
        return toolMap.get(toolName);
      }
    } else if (!arg.includes('=')) {
      if (toolMap.has(arg)) {
        return toolMap.get(arg);
      }
    }
  }
  return null;
}
function parseParams(userArgs: string[], selectedTool: any) {
  const params: Record<string, any> = {};
  const toolName = selectedTool?.name;
  for (const arg of userArgs) {
    // Skip tool selection
    if (arg === toolName || arg === `--${toolName}` || arg === `--${toolName.replace(/_/g, '-')}`) {
      continue;
    }
    if (arg.includes('=')) {
      const [key, value] = arg.split('=', 2);
      const cleanKey = key.replace(/^--/, '');
      // Try to parse as JSON, fall back to string
      try {
        if (value.startsWith('[') || value.startsWith('{') || value === 'true' || value === 'false' || !isNaN(Number(value))) {
          params[cleanKey] = JSON.parse(value);
        } else {
          params[cleanKey] = value;
        }
      } catch {
        params[cleanKey] = value;
      }
    }
  }
  return params;
}
function extractContent(result: any): any {
  if (!result.content || result.content.length === 0) {
    return null;
  }
  if (result.content.length === 1) {
    const item = result.content[0];
    if (item.type === 'text') {
      try {
        return JSON.parse(item.text);
      } catch {
        return item.text;
      }
    }
    return item;
  }
  return result.content.map((item: any) => {
    if (item.type === 'text') {
      try {
        return JSON.parse(item.text);
      } catch {
        return item.text;
      }
    }
    return item;
  });
}
function printHelp(tools: any[]) {
  console.log('MCPLI - Turn any MCP server into a first-class CLI tool');
  console.log('');
  console.log('Usage:');
  console.log('  mcpli [options] [--tool | tool] [params...] -- <command> [args...]');
  console.log('');
  console.log('Global Options:');
  console.log('  --help, -h     Show this help');
  console.log('  --quiet, -q    Suppress server stderr');
  console.log('  --raw          Print raw MCP response');
  console.log('  --debug        Enable debug output');
  console.log('');
  if (tools.length > 0) {
    console.log('Available Tools:');
    for (const tool of tools) {
      const name = tool.name.replace(/_/g, '-');
      const desc = tool.description || 'No description';
      console.log(`  --${name.padEnd(20)} ${desc.slice(0, 50)}${desc.length > 50 ? '...' : ''}`);
    }
    console.log('');
    console.log('Examples:');
    console.log(`  mcpli --${tools[0].name.replace(/_/g, '-')} -- node server.js`);
    console.log(`  mcpli ${tools[0].name} param="value" -- node server.js`);
  } else {
    console.log('Examples:');
    console.log('  mcpli --help -- node server.js');
  }
}
async function main() {
  try {
    const { globals, childCommand, childArgs, userArgs } = parseArgs(process.argv);
    if (globals.debug) {
      console.error('[DEBUG] Args:', { childCommand, childArgs, userArgs });
    }
    // Discover tools
    const { tools, client, close } = await discoverTools(childCommand, childArgs, globals);
    if (globals.debug) {
      console.error('[DEBUG] Found tools:', tools.map((t: any) => t.name));
    }
    // Show help if requested or no tool specified
    if (globals.help || userArgs.length === 0) {
      printHelp(tools);
      await close();
      return;
    }
    // Find selected tool
    const selectedTool = findTool(userArgs, tools);
    if (!selectedTool) {
      console.error('Error: No tool specified or tool not found');
      console.error('Use --help to see available tools');
      await close();
      process.exit(1);
    }
    if (globals.debug) {
      console.error('[DEBUG] Selected tool:', selectedTool.name);
    }
    // Parse parameters
    const params = parseParams(userArgs, selectedTool);
    if (globals.debug) {
      console.error('[DEBUG] Parameters:', params);
    }
    // Execute tool
    const result = await client.callTool({
      name: selectedTool.name,
      arguments: params
    });
    await close();
    // Output result
    if (globals.raw) {
      console.log(JSON.stringify(result, null, 2));
    } else {
      const extracted = extractContent(result);
      if (extracted !== null) {
        if (typeof extracted === 'string') {
          console.log(extracted);
        } else {
          console.log(JSON.stringify(extracted, null, 2));
        }
      }
    }
  } catch (error) {
    console.error(`Error: ${error instanceof Error ? error.message : error}`);
    process.exit(1);
  }
}
main();
</file>

<file path="mcpli.ts">
#!/usr/bin/env node
/**
 * MCPLI - Turn any MCP server into a first-class CLI tool
 * 
 * This version supports both stateless mode and long-lived daemon processes.
 */
import { Client } from '@modelcontextprotocol/sdk/client/index.js';
import { StdioClientTransport } from '@modelcontextprotocol/sdk/client/stdio.js';
import { DaemonClient } from './daemon/index.js';
import { 
  handleDaemonStart, 
  handleDaemonStop, 
  handleDaemonStatus, 
  handleDaemonRestart,
  handleDaemonLogs,
  handleDaemonClean,
  printDaemonHelp
} from './daemon/index.js';
interface GlobalOptions {
  help?: boolean;
  quiet?: boolean;
  raw?: boolean;
  debug?: boolean;
  logs?: boolean;
  verbose?: boolean;
  timeout?: number;
  daemon?: boolean;
  force?: boolean;
}
function parseArgs(argv: string[]) {
  const args = argv.slice(2); // Remove node and script name
  const globals: GlobalOptions = { timeout: 30000 };
  // Check for daemon subcommand
  if (args[0] === 'daemon') {
    globals.daemon = true;
    // Check if help is requested for daemon
    if (args[1] === '--help' || args[1] === '-h') {
      globals.help = true;
      return { 
        globals, 
        daemonCommand: '',
        daemonArgs: [],
        childCommand: '',
        childArgs: [],
        userArgs: []
      };
    }
    const daemonCommand = args[1];
    const daemonArgs = args.slice(2);
    // Parse daemon-specific options
    for (const arg of daemonArgs) {
      if (arg === '--help' || arg === '-h') globals.help = true;
      else if (arg === '--debug') globals.debug = true;
      else if (arg === '--logs') globals.logs = true;
      else if (arg === '--verbose') globals.verbose = true;
      else if (arg === '--force') globals.force = true;
      else if (arg.startsWith('--timeout=')) {
        globals.timeout = parseInt(arg.split('=')[1], 10);
      }
    }
    return { 
      globals, 
      daemonCommand, 
      daemonArgs,
      childCommand: '',
      childArgs: [],
      userArgs: []
    };
  }
  // Regular tool execution mode - find the -- separator
  const dashIndex = args.indexOf('--');
  if (dashIndex === -1) {
    // For help or when no command specified, allow missing --
    if (args.includes('--help') || args.includes('-h') || args.length === 0) {
      return {
        globals: { ...globals, help: true },
        childCommand: '',
        childArgs: [],
        userArgs: args
      };
    }
    // Check if there might be a daemon running - allow daemon mode
    // In daemon mode, no -- is required as the server is already running
    return {
      globals,
      childCommand: '', // Empty means try daemon mode
      childArgs: [],
      userArgs: args
    };
  }
  const childCommand = args[dashIndex + 1];
  const childArgs = args.slice(dashIndex + 2);
  const userArgs = args.slice(0, dashIndex);
  if (!childCommand) {
    console.error('Error: Child command required after --');
    process.exit(1);
  }
  // Parse global options - but don't set help=true if there's a tool name before --help
  let foundToolName = false;
  for (const arg of userArgs) {
    if (!arg.startsWith('--') && !arg.startsWith('-') && !foundToolName) {
      foundToolName = true; // This might be a tool name
      continue;
    }
    if (arg === '--help' || arg === '-h') {
      // Only set global help if no tool name was found
      if (!foundToolName) {
        globals.help = true;
      }
    }
    else if (arg === '--quiet' || arg === '-q') globals.quiet = true;
    else if (arg === '--raw') globals.raw = true;
    else if (arg === '--debug') globals.debug = true;
    else if (arg === '--logs') globals.logs = true;
    else if (arg === '--verbose') globals.verbose = true;
    else if (arg.startsWith('--timeout=')) {
      globals.timeout = parseInt(arg.split('=')[1], 10);
    }
  }
  return { globals, childCommand, childArgs, userArgs };
}
async function discoverTools(command: string, args: string[], options: GlobalOptions) {
  // If no command provided, only try daemon mode (no fallback to stateless)
  const daemonOnly = !command;
  // Try daemon client first, with fallback to direct connection
  const daemonClient = new DaemonClient(command, args, {
    logs: options.logs || options.verbose,
    debug: options.debug,
    timeout: options.timeout,
    autoStart: !daemonOnly, // Don't auto-start if command is empty
    fallbackToStateless: !daemonOnly // No fallback if daemon-only mode
  });
  try {
    const result = await daemonClient.listTools();
    return { 
      tools: result.tools || [], 
      daemonClient,
      isDaemon: true,
      close: () => Promise.resolve()
    };
  } catch (error) {
    // If daemon-only mode (no command), don't try direct connection
    if (daemonOnly) {
      throw error;
    }
    // Fallback to direct connection
    if (options.debug) {
      console.error('[DEBUG] Daemon failed, using direct connection:', error);
    }
    const transport = new StdioClientTransport({
      command,
      args,
      stderr: (options.logs || options.verbose) ? 'inherit' : 'ignore'
    });
    const client = new Client({
      name: 'mcpli',
      version: '1.0.0'
    }, {
      capabilities: {}
    });
    try {
      await client.connect(transport);
      const result = await client.listTools();
      return { 
        tools: result.tools || [], 
        client, 
        isDaemon: false,
        close: () => client.close() 
      };
    } catch (error) {
      throw new Error(`Failed to connect to MCP server: ${error instanceof Error ? error.message : error}`);
    }
  }
}
function normalizeToolName(name: string): string {
  return name.toLowerCase().replace(/[^a-z0-9]/g, '');
}
function findTool(userArgs: string[], tools: any[]) {
  const toolMap = new Map();
  // Build tool index
  for (const tool of tools) {
    const name = tool.name;
    toolMap.set(name, tool);
    toolMap.set(name.replace(/_/g, '-'), tool);
    toolMap.set(normalizeToolName(name), tool);
  }
  // Look for tool selection - first non-option argument is the tool name
  for (const arg of userArgs) {
    if (!arg.startsWith('--') && !arg.startsWith('-')) {
      if (toolMap.has(arg)) {
        return { tool: toolMap.get(arg), toolName: arg };
      }
    }
  }
  return null;
}
function parseParams(userArgs: string[], selectedTool: any, toolName: string): Record<string, any> {
  const params: Record<string, any> = {};
  const schema = selectedTool.inputSchema?.properties || {};
  // Find the start of parameters for the selected tool
  const toolNameIndex = userArgs.indexOf(toolName);
  if (toolNameIndex === -1) {
    // This should not happen if findTool worked correctly, but as a safeguard.
    return {};
  }
  const paramArgs = userArgs.slice(toolNameIndex + 1);
  const args: { key: string, value: string | boolean }[] = [];
  // Phase 1: Tokenize arguments into a structured list of key-value pairs
  for (let i = 0; i < paramArgs.length; i++) {
    const arg = paramArgs[i];
    let key: string | undefined;
    let value: string | boolean | undefined;
    if (arg.startsWith('--')) {
      if (arg.includes('=')) {
        const parts = arg.split('=', 2);
        key = parts[0].slice(2);
        value = parts[1];
      } else {
        key = arg.slice(2);
        const nextArg = paramArgs[i + 1];
        if (nextArg && (!nextArg.startsWith('-') || !isNaN(Number(nextArg)))) {
          value = nextArg;
          i++; // Consume value argument
        } else {
          value = true; // It's a boolean flag
        }
      }
    } else if (arg.startsWith('-') && arg.length === 2 && isNaN(Number(arg[1]))) {
      // Handle short-form arguments like -f (but not negative numbers like -5)
      key = arg.slice(1);
      const nextArg = paramArgs[i + 1];
      if (nextArg && (!nextArg.startsWith('-') || !isNaN(Number(nextArg)))) {
        value = nextArg;
        i++; // Consume value argument
      } else {
        value = true; // It's a boolean flag
      }
    }
    if (key !== undefined && value !== undefined) {
      args.push({ key, value });
    }
    // Non-option arguments (positional) are ignored for now
  }
  // Phase 2: Parse and convert values based on the tool's inputSchema
  for (const { key, value } of args) {
    const propSchema = schema[key];
    if (!propSchema) {
      // If no schema is found for this param, make a best effort to parse
      if (value === true) {
        params[key] = true;
      } else {
        try {
          params[key] = JSON.parse(value as string);
        } catch {
          params[key] = value;
        }
      }
      continue;
    }
    // Handle boolean type specifically, as it can be a flag or have a value
    if (propSchema.type === 'boolean') {
      if (value === true) {
        params[key] = true;
        continue;
      }
      const strValue = String(value).toLowerCase();
      if (strValue === 'true') {
        params[key] = true;
      } else if (strValue === 'false') {
        params[key] = false;
      } else {
        throw new Error(`Argument --${key} expects a boolean (true/false), but received "${value}".`);
      }
      continue;
    }
    // For all other types, a valueless flag is an error
    if (value === true) {
      throw new Error(`Argument --${key} of type "${propSchema.type}" requires a value.`);
    }
    const strValue = value as string;
    switch (propSchema.type) {
      case 'string':
        params[key] = strValue;
        break;
      case 'number':
      case 'integer':
        const num = Number(strValue);
        if (isNaN(num) || strValue.trim() === '') {
          throw new Error(`Argument --${key} expects a ${propSchema.type}, but received "${strValue}".`);
        }
        if (propSchema.type === 'integer' && !Number.isInteger(num)) {
          throw new Error(`Argument --${key} expects an integer, but received "${strValue}".`);
        }
        params[key] = num;
        break;
      case 'array':
      case 'object':
        try {
          params[key] = JSON.parse(strValue);
        } catch (e) {
          throw new Error(`Argument --${key} expects a valid JSON ${propSchema.type}. Parse error: ${e instanceof Error ? e.message : String(e)} on input: "${strValue}"`);
        }
        break;
      case 'null':
        if (strValue.toLowerCase() !== 'null') {
          throw new Error(`Argument --${key} expects null, but received "${strValue}".`);
        }
        params[key] = null;
        break;
      default:
        // Fallback for schemas with anyOf, oneOf, or no type property.
        try {
          params[key] = JSON.parse(strValue);
        } catch {
          params[key] = strValue;
        }
    }
  }
  return params;
}
function extractContent(result: any): any {
  if (!result.content || result.content.length === 0) {
    return null;
  }
  if (result.content.length === 1) {
    const item = result.content[0];
    if (item.type === 'text') {
      try {
        return JSON.parse(item.text);
      } catch {
        return item.text;
      }
    }
    return item;
  }
  return result.content.map((item: any) => {
    if (item.type === 'text') {
      try {
        return JSON.parse(item.text);
      } catch {
        return item.text;
      }
    }
    return item;
  });
}
function printHelp(tools: any[], specificTool?: any) {
  if (specificTool) {
    printToolHelp(specificTool);
    return;
  }
  console.log('MCPLI - Turn any MCP server into a first-class CLI tool');
  console.log('');
  console.log('Usage:');
  console.log('  mcpli <tool> [tool-options...] -- <mcp-server-command> [args...]');
  console.log('  mcpli <tool> --help -- <mcp-server-command> [args...]');
  console.log('  mcpli --help -- <mcp-server-command> [args...]');
  console.log('  mcpli daemon <subcommand> [options]');
  console.log('');
  console.log('Global Options:');
  console.log('  --help, -h     Show this help and list all available tools');
  console.log('  --verbose      Show MCP server output (stderr/logs)');
  console.log('  --raw          Print raw MCP response');
  console.log('  --debug        Enable debug output');
  console.log('  --timeout=<ms> Set daemon timeout (default: 30000)');
  console.log('');
  console.log('Daemon Commands:');
  console.log('  daemon start   Start long-lived daemon process');
  console.log('  daemon stop    Stop daemon process');
  console.log('  daemon status  Show daemon status');
  console.log('  daemon restart Restart daemon process');
  console.log('  daemon logs    Show daemon logs');
  console.log('  daemon clean   Clean up daemon files');
  console.log('');
  if (tools.length > 0) {
    console.log('Available Tools:');
    for (const tool of tools) {
      const name = tool.name.replace(/_/g, '-');
      const desc = tool.description || 'No description';
      console.log(`  ${name.padEnd(20)} ${desc.slice(0, 60)}${desc.length > 60 ? '...' : ''}`);
    }
    console.log('');
    console.log('Tool Help:');
    console.log(`  mcpli <tool> --help -- <mcp-server-command>    Show detailed help for specific tool`);
    console.log('');
    console.log('Examples:');
    console.log(`  mcpli ${tools[0].name.replace(/_/g, '-')} --help -- node server.js`);
    console.log(`  mcpli ${tools[0].name.replace(/_/g, '-')} --option value -- node server.js`);
    console.log('');
    console.log('Fast Execution (via auto-daemon):');
    console.log(`  mcpli ${tools[0].name.replace(/_/g, '-')} --option value  # No MCP server command needed after first use`);
  } else {
    console.log('No tools found. The MCP server may not be responding correctly.');
    console.log('');
    console.log('Examples:');
    console.log('  mcpli --help -- node server.js       # Show tools from server.js');
    console.log('  mcpli daemon start -- node server.js # Start long-lived daemon');
  }
}
function printToolHelp(tool: any) {
  console.log(`MCPLI Tool: ${tool.name}`);
  console.log('');
  if (tool.description) {
    console.log(`Description: ${tool.description}`);
    console.log('');
  }
  console.log(`Usage: mcpli ${tool.name} [options] -- <mcp-server-command> [args...]`);
  console.log('');
  if (tool.inputSchema && tool.inputSchema.properties) {
    console.log('Options:');
    const properties = tool.inputSchema.properties;
    const required = tool.inputSchema.required || [];
    for (const [propName, propSchema] of Object.entries(properties)) {
      const schema = propSchema as any;
      const isRequired = required.includes(propName);
      const type = schema.type || 'string';
      const description = schema.description || '';
      const defaultValue = schema.default;
      let line = `  --${propName.padEnd(20)}`;
      if (type) line += ` (${type})`;
      if (isRequired) line += ' [required]';
      if (description) line += ` ${description}`;
      if (defaultValue !== undefined) line += ` (default: ${JSON.stringify(defaultValue)})`;
      console.log(line);
    }
    console.log('');
  }
  console.log('Examples:');
  const exampleName = tool.name.replace(/_/g, '-');
  console.log(`  mcpli ${exampleName} --help -- node server.js`);
  if (tool.inputSchema && tool.inputSchema.properties) {
    const properties = Object.keys(tool.inputSchema.properties);
    if (properties.length > 0) {
      const firstProp = properties[0];
      console.log(`  mcpli ${exampleName} --${firstProp} "example-value" -- node server.js`);
    }
  }
}
async function main() {
  try {
    const result = parseArgs(process.argv);
    const { globals } = result;
    if (globals.debug) {
      console.error('[DEBUG] Parsed args:', result);
    }
    // Handle daemon subcommands
    if (globals.daemon) {
      const { daemonCommand, daemonArgs } = result as any;
      if (globals.help || !daemonCommand) {
        printDaemonHelp();
        return;
      }
      const options = {
        debug: globals.debug,
        logs: globals.logs || globals.verbose,
        force: globals.force,
        timeout: globals.timeout
      };
      switch (daemonCommand) {
        case 'start':
          const dashIndex = daemonArgs.indexOf('--');
          if (dashIndex === -1) {
            console.error('Error: Command required after -- for daemon start');
            console.error('Usage: mcpli daemon start -- <command> [args...]');
            process.exit(1);
          }
          const command = daemonArgs[dashIndex + 1];
          const args = daemonArgs.slice(dashIndex + 2);
          if (!command) {
            console.error('Error: Command required after --');
            process.exit(1);
          }
          await handleDaemonStart(command, args, options);
          break;
        case 'stop':
          await handleDaemonStop(options);
          break;
        case 'status':
          await handleDaemonStatus(options);
          break;
        case 'restart':
          const restartDashIndex = daemonArgs.indexOf('--');
          if (restartDashIndex === -1) {
            console.error('Error: Command required after -- for daemon restart');
            console.error('Usage: mcpli daemon restart -- <command> [args...]');
            process.exit(1);
          }
          const restartCommand = daemonArgs[restartDashIndex + 1];
          const restartArgs = daemonArgs.slice(restartDashIndex + 2);
          if (!restartCommand) {
            console.error('Error: Command required after --');
            process.exit(1);
          }
          await handleDaemonRestart(restartCommand, restartArgs, options);
          break;
        case 'logs':
          await handleDaemonLogs(options);
          break;
        case 'clean':
          await handleDaemonClean(options);
          break;
        default:
          console.error(`Error: Unknown daemon command: ${daemonCommand}`);
          console.error('Use "mcpli daemon --help" to see available commands');
          process.exit(1);
      }
      return;
    }
    // Regular tool execution mode
    const { childCommand, childArgs, userArgs } = result;
    // No error for missing childCommand - we'll try daemon mode first
    // Show help for regular mode
    if (globals.help) {
      if (childCommand) {
        // Get tools to show in help - always discover tools for root help
        try {
          const { tools, close } = await discoverTools(childCommand, childArgs, globals);
          printHelp(tools);
          await close();
        } catch (error) {
          console.error(`Error connecting to MCP server: ${error instanceof Error ? error.message : error}`);
          console.error('Cannot show available tools. Please check your MCP server command.');
          printHelp([]);
        }
      } else {
        // Try daemon mode for help - discover tools from running daemon
        try {
          const { tools, close } = await discoverTools('', [], globals);
          printHelp(tools);
          await close();
        } catch (error) {
          console.error('Error: No daemon running and MCP server command not provided');
          console.error('Usage: mcpli --help -- <mcp-server-command> [args...]');
          console.error('Example: mcpli --help -- node server.js');
          printHelp([]);
        }
      }
      return;
    }
    if (globals.debug) {
      console.error('[DEBUG] Tool execution mode:', { childCommand, childArgs, userArgs });
    }
    // Discover tools
    const { tools, client, daemonClient, isDaemon, close } = await discoverTools(childCommand, childArgs, globals);
    if (globals.debug) {
      console.error('[DEBUG] Found tools:', tools.map((t: any) => t.name));
      console.error('[DEBUG] Using daemon:', isDaemon);
    }
    // Show help if no tool specified
    if (userArgs.length === 0) {
      printHelp(tools);
      await close();
      return;
    }
    // Find selected tool
    const toolResult = findTool(userArgs, tools);
    if (!toolResult) {
      console.error('Error: No tool specified or tool not found');
      console.error('Available tools:', tools.map((t: any) => t.name.replace(/_/g, '-')).join(', '));
      console.error('Use --help to see all available tools');
      await close();
      process.exit(1);
    }
    const { tool: selectedTool, toolName } = toolResult;
    // Check for tool-specific help
    const hasHelp = userArgs.some((arg: string) => arg === '--help' || arg === '-h');
    if (hasHelp) {
      printHelp(tools, selectedTool);
      await close();
      return;
    }
    if (globals.debug) {
      console.error('[DEBUG] Selected tool:', selectedTool.name);
      console.error('[DEBUG] Tool name used:', toolName);
    }
    // Parse parameters
    const params = parseParams(userArgs, selectedTool, toolName);
    if (globals.debug) {
      console.error('[DEBUG] Parameters:', params);
    }
    // Execute tool using appropriate client
    let executionResult;
    if (isDaemon && daemonClient) {
      executionResult = await daemonClient.callTool({
        name: selectedTool.name,
        arguments: params
      });
    } else if (client) {
      executionResult = await client.callTool({
        name: selectedTool.name,
        arguments: params
      });
    } else {
      throw new Error('No client available for tool execution');
    }
    await close();
    // Output result
    if (globals.raw) {
      console.log(JSON.stringify(executionResult, null, 2));
    } else {
      const extracted = extractContent(executionResult);
      if (extracted !== null) {
        if (typeof extracted === 'string') {
          console.log(extracted);
        } else {
          console.log(JSON.stringify(extracted, null, 2));
        }
      }
    }
  } catch (error) {
    console.error(`Error: ${error instanceof Error ? error.message : error}`);
    process.exit(1);
  }
}
main();
</file>

</files>
