This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where empty lines have been removed.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: **/*, .cursorrules, .cursor/rules/*, .clinerules, CLAUDE.md
- Files matching these patterns are excluded: .*.*, **/*.pbxproj, **/node_modules/**, **/dist/**, **/build/**, **/compile/**, **/*.spec.*, **/*.pyc, **/.env, **/.env.*, **/*.env, **/*.env.*, **/*.lock, **/*.lockb, **/package-lock.*, **/pnpm-lock.*, **/*.tsbuildinfo, **/certdata.txt
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Empty lines have been removed from all files
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.claude/
  settings.local.json
.mcpli/
src/
  daemon/
    client.ts
    commands.ts
    index.ts
    ipc.ts
    lock.ts
    spawn.ts
    wrapper.js
  .repomix-output.txt
  mcpli-backup.ts
  mcpli.ts
.gitignore
complex-test-server.js
LONG_LIVED_DESIGN.md
package.json
README.md
test-server.js
tsconfig.json
weather-server.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/.repomix-output.txt">
This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where empty lines have been removed.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: **/*, .cursorrules, .cursor/rules/*, .clinerules, CLAUDE.md
- Files matching these patterns are excluded: .*.*, **/*.pbxproj, **/node_modules/**, **/dist/**, **/build/**, **/compile/**, **/*.spec.*, **/*.pyc, **/.env, **/.env.*, **/*.env, **/*.env.*, **/*.lock, **/*.lockb, **/package-lock.*, **/pnpm-lock.*, **/*.tsbuildinfo, **/certdata.txt
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Empty lines have been removed from all files
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
daemon/
  client.ts
  commands.ts
  index.ts
  ipc.ts
  lock.ts
  spawn.ts
  wrapper.js
mcpli-backup.ts
mcpli.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="daemon/client.ts">
import { isDaemonRunning, getDaemonInfo, updateLastAccess } from './lock.js';
import { sendIPCRequest, generateRequestId, testIPCConnection } from './ipc.js';
import { startDaemon, DaemonOptions } from './spawn.js';
export interface DaemonClientOptions extends DaemonOptions {
  autoStart?: boolean;
  fallbackToStateless?: boolean;
}
export class DaemonClient {
  constructor(
    private command: string,
    private args: string[],
    private options: DaemonClientOptions = {}
  ) {
    this.options = {
      autoStart: true,
      fallbackToStateless: true,
      ...options
    };
  }
  async listTools(): Promise<any> {
    try {
      const result = await this.callDaemon('listTools');
      return result;
    } catch (error) {
      if (this.options.fallbackToStateless) {
        if (this.options.debug) {
          console.error('[DEBUG] Daemon listTools failed, falling back to stateless:', error);
        }
        return this.fallbackListTools();
      }
      throw error;
    }
  }
  async callTool(params: { name: string; arguments: any }): Promise<any> {
    try {
      const result = await this.callDaemon('callTool', params);
      return result;
    } catch (error) {
      if (this.options.fallbackToStateless) {
        if (this.options.debug) {
          console.error('[DEBUG] Daemon callTool failed, falling back to stateless:', error);
        }
        return this.fallbackCallTool(params);
      }
      throw error;
    }
  }
  private async callDaemon(method: string, params?: any): Promise<any> {
    const cwd = this.options.cwd || process.cwd();
    // Check if daemon is running
    const isRunning = await isDaemonRunning(cwd);
    if (!isRunning) {
      if (this.options.autoStart && this.command) {
        if (this.options.debug) {
          console.error('[DEBUG] Starting daemon automatically');
        }
        await this.startDaemon();
      } else {
        throw new Error(this.command ? 'Daemon not running and auto-start disabled' : 'No daemon running and no server command provided');
      }
    }
    // Get daemon info
    const daemonInfo = await getDaemonInfo(cwd);
    if (!daemonInfo) {
      throw new Error('Daemon info not available');
    }
    // Test connection
    if (!(await testIPCConnection(daemonInfo))) {
      throw new Error('Cannot connect to daemon IPC socket');
    }
    // Send request
    const request = {
      id: generateRequestId(),
      method: method as 'listTools' | 'callTool' | 'ping',
      params
    };
    const result = await sendIPCRequest(daemonInfo.socket, request);
    // Update last access time
    await updateLastAccess(cwd);
    return result;
  }
  private async startDaemon(): Promise<void> {
    try {
      const daemon = await startDaemon(this.command, this.args, this.options);
      // Wait a moment for daemon to be fully ready
      await new Promise(resolve => setTimeout(resolve, 100));
      if (this.options.debug) {
        console.error('[DEBUG] Daemon started successfully');
      }
    } catch (error) {
      if (this.options.debug) {
        console.error('[DEBUG] Failed to start daemon:', error);
      }
      throw new Error(`Failed to start daemon: ${error instanceof Error ? error.message : error}`);
    }
  }
  private async fallbackListTools(): Promise<any> {
    const { Client } = await import('@modelcontextprotocol/sdk/client/index.js');
    const { StdioClientTransport } = await import('@modelcontextprotocol/sdk/client/stdio.js');
    const transport = new StdioClientTransport({
      command: this.command,
      args: this.args,
      stderr: this.options.logs ? 'inherit' : 'ignore'
    });
    const client = new Client({
      name: 'mcpli',
      version: '1.0.0'
    }, {
      capabilities: {}
    });
    try {
      await client.connect(transport);
      const result = await client.listTools();
      await client.close();
      return result;
    } catch (error) {
      await client.close();
      throw error;
    }
  }
  private async fallbackCallTool(params: { name: string; arguments: any }): Promise<any> {
    const { Client } = await import('@modelcontextprotocol/sdk/client/index.js');
    const { StdioClientTransport } = await import('@modelcontextprotocol/sdk/client/stdio.js');
    const transport = new StdioClientTransport({
      command: this.command,
      args: this.args,
      stderr: this.options.logs ? 'inherit' : 'ignore'
    });
    const client = new Client({
      name: 'mcpli',
      version: '1.0.0'
    }, {
      capabilities: {}
    });
    try {
      await client.connect(transport);
      const result = await client.callTool(params);
      await client.close();
      return result;
    } catch (error) {
      await client.close();
      throw error;
    }
  }
  async ping(): Promise<boolean> {
    try {
      const result = await this.callDaemon('ping');
      return result === 'pong';
    } catch {
      return false;
    }
  }
}
// Convenience function for one-off operations
export async function withDaemonClient<T>(
  command: string,
  args: string[],
  options: DaemonClientOptions,
  operation: (client: DaemonClient) => Promise<T>
): Promise<T> {
  const client = new DaemonClient(command, args, options);
  return await operation(client);
}
</file>

<file path="daemon/commands.ts">
import { 
  isDaemonRunning, 
  getDaemonInfo, 
  stopDaemon, 
  cleanupStaleLock 
} from './lock.js';
import { startDaemon, DaemonOptions } from './spawn.js';
import { testIPCConnection } from './ipc.js';
import fs from 'fs/promises';
import path from 'path';
export interface DaemonCommandOptions extends DaemonOptions {
  force?: boolean;
}
export async function handleDaemonStart(
  command: string, 
  args: string[], 
  options: DaemonCommandOptions = {}
): Promise<void> {
  const cwd = options.cwd || process.cwd();
  // Check if daemon is already running
  if (await isDaemonRunning(cwd)) {
    const info = await getDaemonInfo(cwd);
    console.log(`Daemon is already running (PID ${info?.pid})`);
    return;
  }
  try {
    console.log(`Starting daemon: ${command} ${args.join(' ')}`);
    const daemon = await startDaemon(command, args, options);
    console.log(`Daemon started successfully (PID ${daemon.lock.info.pid})`);
    console.log(`Socket: ${daemon.lock.info.socket}`);
    if (options.debug) {
      console.log('Debug mode enabled - daemon will log to console');
    }
  } catch (error) {
    console.error(`Failed to start daemon: ${error instanceof Error ? error.message : error}`);
    process.exit(1);
  }
}
export async function handleDaemonStop(options: DaemonCommandOptions = {}): Promise<void> {
  const cwd = options.cwd || process.cwd();
  if (!(await isDaemonRunning(cwd))) {
    console.log('No daemon is running');
    return;
  }
  const info = await getDaemonInfo(cwd);
  if (!info) {
    console.log('No daemon information found');
    await cleanupStaleLock(cwd);
    return;
  }
  try {
    console.log(`Stopping daemon (PID ${info.pid})...`);
    const stopped = await stopDaemon(cwd, options.force);
    if (stopped) {
      console.log('Daemon stopped successfully');
    } else {
      console.log('Daemon may have already been stopped');
    }
  } catch (error) {
    console.error(`Failed to stop daemon: ${error instanceof Error ? error.message : error}`);
    process.exit(1);
  }
}
export async function handleDaemonStatus(options: DaemonCommandOptions = {}): Promise<void> {
  const cwd = options.cwd || process.cwd();
  const info = await getDaemonInfo(cwd);
  if (!info) {
    console.log('Status: Not running');
    return;
  }
  const isRunning = await isDaemonRunning(cwd);
  if (!isRunning) {
    console.log('Status: Not running (stale lock file cleaned up)');
    return;
  }
  // Test IPC connection
  const canConnect = await testIPCConnection(info);
  console.log('Status: Running');
  console.log(`PID: ${info.pid}`);
  console.log(`Command: ${info.command} ${info.args.join(' ')}`);
  console.log(`Started: ${new Date(info.started).toLocaleString()}`);
  console.log(`Last access: ${new Date(info.lastAccess).toLocaleString()}`);
  console.log(`Socket: ${info.socket}`);
  console.log(`IPC connection: ${canConnect ? 'OK' : 'FAILED'}`);
  console.log(`Working directory: ${info.cwd}`);
  // Calculate uptime
  const uptimeMs = Date.now() - new Date(info.started).getTime();
  const uptimeMinutes = Math.floor(uptimeMs / 60000);
  const uptimeHours = Math.floor(uptimeMinutes / 60);
  const uptimeDays = Math.floor(uptimeHours / 24);
  let uptimeStr = '';
  if (uptimeDays > 0) uptimeStr += `${uptimeDays}d `;
  if (uptimeHours > 0) uptimeStr += `${uptimeHours % 24}h `;
  uptimeStr += `${uptimeMinutes % 60}m`;
  console.log(`Uptime: ${uptimeStr}`);
  // Calculate idle time
  const idleMs = Date.now() - new Date(info.lastAccess).getTime();
  const idleMinutes = Math.floor(idleMs / 60000);
  const idleHours = Math.floor(idleMinutes / 60);
  let idleStr = '';
  if (idleHours > 0) idleStr += `${idleHours}h `;
  idleStr += `${idleMinutes % 60}m`;
  console.log(`Idle time: ${idleStr}`);
}
export async function handleDaemonRestart(
  command: string,
  args: string[],
  options: DaemonCommandOptions = {}
): Promise<void> {
  console.log('Restarting daemon...');
  // Stop existing daemon
  await handleDaemonStop(options);
  // Wait a moment for cleanup
  await new Promise(resolve => setTimeout(resolve, 500));
  // Start new daemon
  await handleDaemonStart(command, args, options);
}
export async function handleDaemonLogs(options: DaemonCommandOptions = {}): Promise<void> {
  const cwd = options.cwd || process.cwd();
  const logPath = path.join(cwd, '.mcpli', 'daemon.log');
  try {
    const logContent = await fs.readFile(logPath, 'utf8');
    console.log(logContent);
  } catch (error) {
    if ((error as any).code === 'ENOENT') {
      console.log('No log file found. Daemon may not have been started with --logs flag.');
    } else {
      console.error(`Failed to read log file: ${error instanceof Error ? error.message : error}`);
    }
  }
}
export async function handleDaemonClean(options: DaemonCommandOptions = {}): Promise<void> {
  const cwd = options.cwd || process.cwd();
  const mcpliDir = path.join(cwd, '.mcpli');
  try {
    // Stop daemon if running
    if (await isDaemonRunning(cwd)) {
      console.log('Stopping running daemon...');
      await stopDaemon(cwd, true); // Force stop
    }
    // Clean up all daemon files
    const files = [
      'daemon.lock',
      'daemon.sock',
      'daemon.log',
      'daemon.config.json'
    ];
    let cleaned = 0;
    for (const file of files) {
      try {
        await fs.unlink(path.join(mcpliDir, file));
        cleaned++;
      } catch {
        // File doesn't exist, which is fine
      }
    }
    console.log(`Cleaned up ${cleaned} daemon files`);
    // Remove .mcpli directory if empty
    try {
      await fs.rmdir(mcpliDir);
      console.log('Removed empty .mcpli directory');
    } catch {
      // Directory not empty or doesn't exist
    }
  } catch (error) {
    console.error(`Failed to clean daemon files: ${error instanceof Error ? error.message : error}`);
    process.exit(1);
  }
}
export function printDaemonHelp(): void {
  console.log('MCPLI Daemon Management');
  console.log('');
  console.log('Usage:');
  console.log('  mcpli daemon <command> [options]');
  console.log('');
  console.log('Commands:');
  console.log('  start [-- command args...]  Start daemon with MCP server command');
  console.log('  stop                         Stop running daemon');
  console.log('  restart [-- command args...] Restart daemon');
  console.log('  status                       Show daemon status and info');
  console.log('  logs                         Show daemon log output');
  console.log('  clean                        Clean up all daemon files');
  console.log('');
  console.log('Options:');
  console.log('  --force                      Force stop daemon');
  console.log('  --logs                       Enable daemon logging');
  console.log('  --debug                      Enable debug output');
  console.log('  --timeout <ms>               Set daemon inactivity timeout');
  console.log('');
  console.log('Examples:');
  console.log('  mcpli daemon start -- node server.js');
  console.log('  mcpli daemon status');
  console.log('  mcpli daemon stop');
  console.log('  mcpli daemon clean');
}
</file>

<file path="daemon/index.ts">
// Daemon management exports
export * from './lock.js';
export * from './ipc.js';
export * from './spawn.js';
export * from './client.js';
export * from './commands.js';
</file>

<file path="daemon/ipc.ts">
import net from 'net';
import path from 'path';
import { DaemonInfo } from './lock.js';
export interface IPCRequest {
  id: string;
  method: 'listTools' | 'callTool' | 'ping';
  params?: any;
}
export interface IPCResponse {
  id: string;
  result?: any;
  error?: string;
}
export interface IPCServer {
  server: net.Server;
  close: () => Promise<void>;
}
export async function createIPCServer(
  socketPath: string,
  handler: (request: IPCRequest) => Promise<any>
): Promise<IPCServer> {
  // Remove existing socket file if it exists
  try {
    await import('fs/promises').then(fs => fs.unlink(socketPath));
  } catch {
    // Socket file doesn't exist, which is fine
  }
  const server = net.createServer((client) => {
    let buffer = '';
    client.on('data', async (data) => {
      buffer += data.toString();
      // Handle multiple JSON messages in buffer
      while (true) {
        const newlineIndex = buffer.indexOf('\n');
        if (newlineIndex === -1) break;
        const message = buffer.slice(0, newlineIndex);
        buffer = buffer.slice(newlineIndex + 1);
        if (!message.trim()) continue;
        try {
          const request: IPCRequest = JSON.parse(message);
          const result = await handler(request);
          const response: IPCResponse = { id: request.id, result };
          client.write(JSON.stringify(response) + '\n');
        } catch (error) {
          const response: IPCResponse = {
            id: 'unknown',
            error: error instanceof Error ? error.message : String(error)
          };
          client.write(JSON.stringify(response) + '\n');
        }
      }
    });
    client.on('error', (error) => {
      console.error('IPC client error:', error);
    });
  });
  return new Promise((resolve, reject) => {
    server.listen(socketPath, () => {
      resolve({
        server,
        close: () => new Promise((resolve) => {
          server.close(() => {
            // Clean up socket file
            import('fs/promises').then(fs => 
              fs.unlink(socketPath).catch(() => {})
            ).finally(resolve);
          });
        })
      });
    });
    server.on('error', reject);
  });
}
export async function sendIPCRequest(
  socketPath: string,
  request: IPCRequest,
  timeoutMs = 10000
): Promise<any> {
  return new Promise((resolve, reject) => {
    const client = net.connect(socketPath, () => {
      client.write(JSON.stringify(request) + '\n');
    });
    let buffer = '';
    const timeout = setTimeout(() => {
      client.destroy();
      reject(new Error(`IPC request timeout after ${timeoutMs}ms`));
    }, timeoutMs);
    client.on('data', (data) => {
      buffer += data.toString();
      const newlineIndex = buffer.indexOf('\n');
      if (newlineIndex !== -1) {
        const message = buffer.slice(0, newlineIndex);
        clearTimeout(timeout);
        client.end();
        try {
          const response: IPCResponse = JSON.parse(message);
          if (response.error) {
            reject(new Error(response.error));
          } else {
            resolve(response.result);
          }
        } catch (error) {
          reject(new Error(`Invalid IPC response: ${error}`));
        }
      }
    });
    client.on('error', (error) => {
      clearTimeout(timeout);
      reject(error);
    });
    client.on('timeout', () => {
      clearTimeout(timeout);
      client.destroy();
      reject(new Error('IPC connection timeout'));
    });
  });
}
export async function testIPCConnection(daemonInfo: DaemonInfo): Promise<boolean> {
  try {
    const request: IPCRequest = {
      id: Date.now().toString(),
      method: 'ping'
    };
    await sendIPCRequest(daemonInfo.socket, request, 2000);
    return true;
  } catch {
    return false;
  }
}
export function generateRequestId(): string {
  return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
}
</file>

<file path="daemon/lock.ts">
import { lock, unlock } from 'proper-lockfile';
import fs from 'fs/promises';
import path from 'path';
import { existsSync } from 'fs';
export interface DaemonInfo {
  pid: number;
  socket: string;
  command: string;
  args: string[];
  started: string;
  lastAccess: string;
  cwd: string;
}
export interface DaemonLock {
  info: DaemonInfo;
  release: () => Promise<void>;
}
const MCPLI_DIR = '.mcpli';
const LOCK_FILE = 'daemon.lock';
function getMcpliDir(cwd = process.cwd()): string {
  return path.join(cwd, MCPLI_DIR);
}
function getLockPath(cwd = process.cwd()): string {
  return path.join(getMcpliDir(cwd), LOCK_FILE);
}
async function ensureMcpliDir(cwd = process.cwd()): Promise<void> {
  const mcpliDir = getMcpliDir(cwd);
  if (!existsSync(mcpliDir)) {
    await fs.mkdir(mcpliDir, { recursive: true });
  }
}
export async function acquireDaemonLock(
  command: string,
  args: string[],
  cwd = process.cwd()
): Promise<DaemonLock> {
  await ensureMcpliDir(cwd);
  const lockPath = getLockPath(cwd);
  // Create empty lock file if it doesn't exist
  try {
    await fs.access(lockPath);
  } catch {
    await fs.writeFile(lockPath, '{}');
  }
  try {
    // Acquire exclusive lock - will throw if already locked
    const release = await lock(lockPath, { 
      retries: 0,
      stale: 60000 // Consider lock stale after 1 minute
    });
    const daemonInfo: DaemonInfo = {
      pid: process.pid,
      socket: path.join(getMcpliDir(cwd), 'daemon.sock'),
      command,
      args,
      started: new Date().toISOString(),
      lastAccess: new Date().toISOString(),
      cwd
    };
    // Write daemon info to the lock file
    await fs.writeFile(lockPath, JSON.stringify(daemonInfo, null, 2));
    return {
      info: daemonInfo,
      release: async () => {
        try {
          await fs.unlink(lockPath);
        } catch {
          // File might already be deleted
        }
        await release();
      }
    };
  } catch (error) {
    throw new Error(`Cannot acquire daemon lock: ${error instanceof Error ? error.message : error}`);
  }
}
export async function getDaemonInfo(cwd = process.cwd()): Promise<DaemonInfo | null> {
  try {
    const lockPath = getLockPath(cwd);
    const data = await fs.readFile(lockPath, 'utf8');
    return JSON.parse(data);
  } catch {
    return null;
  }
}
export async function updateLastAccess(cwd = process.cwd()): Promise<void> {
  const info = await getDaemonInfo(cwd);
  if (!info) return;
  info.lastAccess = new Date().toISOString();
  const lockPath = getLockPath(cwd);
  try {
    await fs.writeFile(lockPath, JSON.stringify(info, null, 2));
  } catch {
    // Ignore write errors - daemon might be shutting down
  }
}
export async function isDaemonRunning(cwd = process.cwd()): Promise<boolean> {
  const info = await getDaemonInfo(cwd);
  if (!info) return false;
  try {
    // Send test signal - throws if process doesn't exist
    process.kill(info.pid, 0);
    return true;
  } catch {
    // Process not running, clean up stale lock
    await cleanupStaleLock(cwd);
    return false;
  }
}
export async function cleanupStaleLock(cwd = process.cwd()): Promise<void> {
  try {
    const lockPath = getLockPath(cwd);
    await fs.unlink(lockPath);
  } catch {
    // Lock file might not exist or already cleaned up
  }
}
export async function stopDaemon(cwd = process.cwd(), force = false): Promise<boolean> {
  const info = await getDaemonInfo(cwd);
  if (!info) return false;
  try {
    // Send termination signal
    process.kill(info.pid, force ? 'SIGKILL' : 'SIGTERM');
    // Wait for graceful shutdown
    if (!force) {
      // Wait up to 5 seconds for graceful shutdown
      for (let i = 0; i < 50; i++) {
        try {
          process.kill(info.pid, 0);
          await new Promise(resolve => setTimeout(resolve, 100));
        } catch {
          // Process has exited
          break;
        }
      }
      // Force kill if still running
      try {
        process.kill(info.pid, 0);
        process.kill(info.pid, 'SIGKILL');
      } catch {
        // Already exited
      }
    }
    // Clean up lock file
    await cleanupStaleLock(cwd);
    return true;
  } catch {
    // Process might already be dead
    await cleanupStaleLock(cwd);
    return false;
  }
}
</file>

<file path="daemon/spawn.ts">
import { spawn, ChildProcess } from 'child_process';
import path from 'path';
import { fileURLToPath } from 'url';
import { DaemonLock } from './lock.js';
import { createIPCServer, IPCRequest } from './ipc.js';
import { Client } from '@modelcontextprotocol/sdk/client/index.js';
import { StdioClientTransport } from '@modelcontextprotocol/sdk/client/stdio.js';
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
export interface DaemonOptions {
  logs?: boolean;
  debug?: boolean;
  cwd?: string;
  timeout?: number;
}
export interface DaemonProcess {
  lock: DaemonLock;
  close: () => Promise<void>;
}
export async function startDaemon(
  command: string,
  args: string[],
  options: DaemonOptions = {}
): Promise<DaemonProcess> {
  const cwd = options.cwd || process.cwd();
  // Create socket path in .mcpli directory
  const mcpliDir = path.join(cwd, '.mcpli');
  const socketPath = path.join(mcpliDir, 'daemon.sock');
  // Ensure .mcpli directory exists
  const fs = await import('fs/promises');
  const { existsSync } = await import('fs');
  if (!existsSync(mcpliDir)) {
    await fs.mkdir(mcpliDir, { recursive: true });
  }
  // Create wrapper script path
  const wrapperPath = path.join(__dirname, 'wrapper.js');
  // Spawn the daemon wrapper process as truly detached
  const daemon = spawn('node', [wrapperPath], {
    detached: true,
    stdio: 'ignore', // Completely detach from parent
    cwd,
    env: {
      ...process.env,
      MCPLI_SOCKET_PATH: socketPath,
      MCPLI_CWD: cwd,
      MCPLI_DEBUG: options.debug ? '1' : '0',
      MCPLI_TIMEOUT: (options.timeout || 30 * 60 * 1000).toString(),
      MCPLI_LOGS: options.logs ? '1' : '0',
      MCPLI_COMMAND: command,
      MCPLI_ARGS: JSON.stringify(args)
    }
  });
  // Allow parent to exit independently - this is crucial
  daemon.unref();
  // Wait for daemon to be ready
  await waitForDaemonReady(socketPath, 10000);
  // Get the lock info from the daemon
  const { getDaemonInfo } = await import('./lock.js');
  const lock = await getDaemonInfo(cwd);
  if (!lock) {
    throw new Error('Failed to get daemon lock info after startup');
  }
  return {
    lock: {
      info: lock,
      release: async () => {
        // Lock is now owned by daemon - don't release here
      }
    },
    close: async () => {
      try {
        if (daemon.pid) {
          process.kill(daemon.pid, 'SIGTERM');
          // Wait for graceful shutdown
          await new Promise(resolve => {
            const timeout = setTimeout(resolve, 5000);
            daemon.on('exit', () => {
              clearTimeout(timeout);
              resolve(undefined);
            });
          });
          // Force kill if still running
          try {
            if (daemon.pid) {
              process.kill(daemon.pid, 'SIGKILL');
            }
          } catch {
            // Already dead
          }
        }
      } catch {
        // Process might already be dead
      }
    }
  };
}
async function waitForDaemonReady(socketPath: string, timeoutMs: number): Promise<void> {
  const start = Date.now();
  while (Date.now() - start < timeoutMs) {
    try {
      const { sendIPCRequest, generateRequestId } = await import('./ipc.js');
      await sendIPCRequest(socketPath, {
        id: generateRequestId(),
        method: 'ping'
      }, 1000);
      return;
    } catch {
      await new Promise(resolve => setTimeout(resolve, 100));
    }
  }
  throw new Error(`Daemon failed to start within ${timeoutMs}ms`);
}
// In-process daemon for development/testing
export class InProcessDaemon {
  private mcpClient?: Client;
  private ipcServer?: any;
  public lock?: DaemonLock;
  private inactivityTimeout?: NodeJS.Timeout;
  constructor(
    private command: string,
    private args: string[],
    private options: DaemonOptions = {}
  ) {}
  async start(): Promise<void> {
    const cwd = this.options.cwd || process.cwd();
    // Acquire lock
    const { acquireDaemonLock } = await import('./lock.js');
    this.lock = await acquireDaemonLock(this.command, this.args, cwd);
    // Start MCP client
    const transport = new StdioClientTransport({
      command: this.command,
      args: this.args,
      stderr: this.options.logs ? 'inherit' : 'ignore'
    });
    this.mcpClient = new Client({
      name: 'mcpli-daemon',
      version: '1.0.0'
    }, {
      capabilities: {}
    });
    await this.mcpClient.connect(transport);
    // Start IPC server
    this.ipcServer = await createIPCServer(
      this.lock!.info.socket,
      this.handleIPCRequest.bind(this)
    );
    // Set up inactivity timeout
    this.resetInactivityTimer();
    // Set up cleanup handlers
    process.on('SIGTERM', this.gracefulShutdown.bind(this));
    process.on('SIGINT', this.gracefulShutdown.bind(this));
  }
  private async handleIPCRequest(request: IPCRequest): Promise<any> {
    this.resetInactivityTimer();
    switch (request.method) {
      case 'ping':
        return 'pong';
      case 'listTools':
        if (!this.mcpClient) throw new Error('MCP client not connected');
        const result = await this.mcpClient.listTools();
        return result;
      case 'callTool':
        if (!this.mcpClient) throw new Error('MCP client not connected');
        return await this.mcpClient.callTool(request.params);
      default:
        throw new Error(`Unknown method: ${request.method}`);
    }
  }
  private resetInactivityTimer(): void {
    if (this.inactivityTimeout) {
      clearTimeout(this.inactivityTimeout);
    }
    const timeoutMs = this.options.timeout || 30 * 60 * 1000; // 30 minutes
    this.inactivityTimeout = setTimeout(() => {
      this.gracefulShutdown();
    }, timeoutMs);
  }
  private async gracefulShutdown(): Promise<void> {
    if (this.options.debug) {
      console.error('[DEBUG] Daemon shutting down gracefully');
    }
    // Clear timeout
    if (this.inactivityTimeout) {
      clearTimeout(this.inactivityTimeout);
    }
    // Close IPC server
    if (this.ipcServer) {
      await this.ipcServer.close();
    }
    // Close MCP client
    if (this.mcpClient) {
      await this.mcpClient.close();
    }
    // Release lock
    if (this.lock) {
      await this.lock.release();
    }
    process.exit(0);
  }
  async close(): Promise<void> {
    await this.gracefulShutdown();
  }
}
</file>

<file path="daemon/wrapper.js">
#!/usr/bin/env node
/**
 * MCPLI Daemon Wrapper - Long-lived MCP server process
 * 
 * This script runs as a detached daemon process and manages
 * a connection to an MCP server while providing IPC interface
 * for MCPLI commands.
 */
import { createIPCServer } from './ipc.js';
import { Client } from '@modelcontextprotocol/sdk/client/index.js';
import { StdioClientTransport } from '@modelcontextprotocol/sdk/client/stdio.js';
import { acquireDaemonLock } from './lock.js';
class MCPLIDaemon {
  constructor() {
    this.mcpClient = null;
    this.ipcServer = null;
    this.inactivityTimeout = null;
    this.isShuttingDown = false;
    this.daemonLock = null;
    // Read environment variables
    this.socketPath = process.env.MCPLI_SOCKET_PATH;
    this.cwd = process.env.MCPLI_CWD || process.cwd();
    this.debug = process.env.MCPLI_DEBUG === '1';
    this.logs = process.env.MCPLI_LOGS === '1';
    this.timeoutMs = parseInt(process.env.MCPLI_TIMEOUT || '1800000', 10); // 30 minutes
    this.mcpCommand = process.env.MCPLI_COMMAND;
    this.mcpArgs = JSON.parse(process.env.MCPLI_ARGS || '[]');
    if (!this.socketPath || !this.mcpCommand) {
      console.error('Missing required environment variables or arguments');
      process.exit(1);
    }
  }
  async start() {
    try {
      if (this.debug) {
        console.error(`[DAEMON] Starting with command: ${this.mcpCommand} ${this.mcpArgs.join(' ')}`);
        console.error(`[DAEMON] Socket path: ${this.socketPath}`);
      }
      // Acquire daemon lock - this writes the correct PID (our PID)
      this.daemonLock = await acquireDaemonLock(this.mcpCommand, this.mcpArgs, this.cwd);
      if (this.debug) {
        console.error(`[DAEMON] Lock acquired for PID ${this.daemonLock.info.pid}`);
      }
      // Start MCP client
      await this.startMCPClient();
      // Start IPC server
      await this.startIPCServer();
      // Set up cleanup handlers
      process.on('SIGTERM', this.gracefulShutdown.bind(this));
      process.on('SIGINT', this.gracefulShutdown.bind(this));
      process.on('uncaughtException', this.handleError.bind(this));
      process.on('unhandledRejection', this.handleError.bind(this));
      // Start inactivity timer
      this.resetInactivityTimer();
      if (this.debug) {
        console.error('[DAEMON] Started successfully');
      }
    } catch (error) {
      console.error('[DAEMON] Failed to start:', error);
      process.exit(1);
    }
  }
  async startMCPClient() {
    const transport = new StdioClientTransport({
      command: this.mcpCommand,
      args: this.mcpArgs,
      stderr: (this.debug || this.logs) ? 'inherit' : 'ignore'
    });
    this.mcpClient = new Client({
      name: 'mcpli-daemon',
      version: '1.0.0'
    }, {
      capabilities: {}
    });
    await this.mcpClient.connect(transport);
    if (this.debug) {
      console.error('[DAEMON] MCP client connected');
    }
  }
  async startIPCServer() {
    this.ipcServer = await createIPCServer(
      this.socketPath,
      this.handleIPCRequest.bind(this)
    );
    if (this.debug) {
      console.error('[DAEMON] IPC server listening on:', this.socketPath);
    }
  }
  async handleIPCRequest(request) {
    this.resetInactivityTimer();
    if (this.debug) {
      console.error(`[DAEMON] Handling IPC request: ${request.method}`);
    }
    switch (request.method) {
      case 'ping':
        return 'pong';
      case 'listTools':
        if (!this.mcpClient) throw new Error('MCP client not connected');
        const result = await this.mcpClient.listTools();
        return result;
      case 'callTool':
        if (!this.mcpClient) throw new Error('MCP client not connected');
        return await this.mcpClient.callTool(request.params);
      default:
        throw new Error(`Unknown method: ${request.method}`);
    }
  }
  resetInactivityTimer() {
    if (this.inactivityTimeout) {
      clearTimeout(this.inactivityTimeout);
    }
    this.inactivityTimeout = setTimeout(() => {
      if (this.debug) {
        console.error('[DAEMON] Shutting down due to inactivity');
      }
      this.gracefulShutdown();
    }, this.timeoutMs);
  }
  async gracefulShutdown() {
    if (this.isShuttingDown) return;
    this.isShuttingDown = true;
    if (this.debug) {
      console.error('[DAEMON] Starting graceful shutdown');
    }
    // Clear inactivity timer
    if (this.inactivityTimeout) {
      clearTimeout(this.inactivityTimeout);
    }
    try {
      // Close IPC server
      if (this.ipcServer) {
        await this.ipcServer.close();
        if (this.debug) {
          console.error('[DAEMON] IPC server closed');
        }
      }
      // Close MCP client
      if (this.mcpClient) {
        await this.mcpClient.close();
        if (this.debug) {
          console.error('[DAEMON] MCP client closed');
        }
      }
    } catch (error) {
      console.error('[DAEMON] Error during shutdown:', error);
    }
    // Release the daemon lock
    if (this.daemonLock) {
      await this.daemonLock.release();
      if (this.debug) {
        console.error('[DAEMON] Lock released');
      }
    }
    if (this.debug) {
      console.error('[DAEMON] Shutdown complete');
    }
    process.exit(0);
  }
  handleError(error) {
    console.error('[DAEMON] Unhandled error:', error);
    this.gracefulShutdown();
  }
}
// Start the daemon
const daemon = new MCPLIDaemon();
daemon.start().catch(error => {
  console.error('[DAEMON] Fatal error:', error);
  process.exit(1);
});
</file>

<file path="mcpli-backup.ts">
#!/usr/bin/env node
/**
 * MCPLI - Turn any MCP server into a first-class CLI tool
 * 
 * This is a minimal working version to demonstrate the core concept.
 */
import { Client } from '@modelcontextprotocol/sdk/client/index.js';
import { StdioClientTransport } from '@modelcontextprotocol/sdk/client/stdio.js';
interface GlobalOptions {
  help?: boolean;
  quiet?: boolean;
  raw?: boolean;
  debug?: boolean;
  timeout?: number;
}
function parseArgs(argv: string[]) {
  const args = argv.slice(2); // Remove node and script name
  const globals: GlobalOptions = { timeout: 30000 };
  // Find the -- separator
  const dashIndex = args.indexOf('--');
  if (dashIndex === -1) {
    console.error('Error: Child command required after --');
    console.error('Usage: mcpli [options] [tool] [params...] -- <command> [args...]');
    process.exit(1);
  }
  const childCommand = args[dashIndex + 1];
  const childArgs = args.slice(dashIndex + 2);
  const userArgs = args.slice(0, dashIndex);
  if (!childCommand) {
    console.error('Error: Child command required after --');
    process.exit(1);
  }
  // Parse global options
  for (const arg of userArgs) {
    if (arg === '--help' || arg === '-h') globals.help = true;
    else if (arg === '--quiet' || arg === '-q') globals.quiet = true;
    else if (arg === '--raw') globals.raw = true;
    else if (arg === '--debug') globals.debug = true;
  }
  return { globals, childCommand, childArgs, userArgs };
}
async function discoverTools(command: string, args: string[], options: GlobalOptions) {
  const transport = new StdioClientTransport({
    command,
    args,
    stderr: options.quiet ? 'ignore' : 'inherit'
  });
  const client = new Client({
    name: 'mcpli',
    version: '1.0.0'
  }, {
    capabilities: {}
  });
  try {
    await client.connect(transport);
    const result = await client.listTools();
    return { tools: result.tools || [], client, close: () => client.close() };
  } catch (error) {
    throw new Error(`Failed to connect to MCP server: ${error instanceof Error ? error.message : error}`);
  }
}
function normalizeToolName(name: string): string {
  return name.toLowerCase().replace(/[^a-z0-9]/g, '');
}
function findTool(userArgs: string[], tools: any[]) {
  const toolMap = new Map();
  // Build tool index
  for (const tool of tools) {
    const name = tool.name;
    toolMap.set(name, tool);
    toolMap.set(name.replace(/_/g, '-'), tool);
    toolMap.set(normalizeToolName(name), tool);
  }
  // Look for tool selection
  for (const arg of userArgs) {
    if (arg.startsWith('--')) {
      const toolName = arg.slice(2);
      if (toolMap.has(toolName)) {
        return toolMap.get(toolName);
      }
    } else if (!arg.includes('=')) {
      if (toolMap.has(arg)) {
        return toolMap.get(arg);
      }
    }
  }
  return null;
}
function parseParams(userArgs: string[], selectedTool: any) {
  const params: Record<string, any> = {};
  const toolName = selectedTool?.name;
  for (const arg of userArgs) {
    // Skip tool selection
    if (arg === toolName || arg === `--${toolName}` || arg === `--${toolName.replace(/_/g, '-')}`) {
      continue;
    }
    if (arg.includes('=')) {
      const [key, value] = arg.split('=', 2);
      const cleanKey = key.replace(/^--/, '');
      // Try to parse as JSON, fall back to string
      try {
        if (value.startsWith('[') || value.startsWith('{') || value === 'true' || value === 'false' || !isNaN(Number(value))) {
          params[cleanKey] = JSON.parse(value);
        } else {
          params[cleanKey] = value;
        }
      } catch {
        params[cleanKey] = value;
      }
    }
  }
  return params;
}
function extractContent(result: any): any {
  if (!result.content || result.content.length === 0) {
    return null;
  }
  if (result.content.length === 1) {
    const item = result.content[0];
    if (item.type === 'text') {
      try {
        return JSON.parse(item.text);
      } catch {
        return item.text;
      }
    }
    return item;
  }
  return result.content.map((item: any) => {
    if (item.type === 'text') {
      try {
        return JSON.parse(item.text);
      } catch {
        return item.text;
      }
    }
    return item;
  });
}
function printHelp(tools: any[]) {
  console.log('MCPLI - Turn any MCP server into a first-class CLI tool');
  console.log('');
  console.log('Usage:');
  console.log('  mcpli [options] [--tool | tool] [params...] -- <command> [args...]');
  console.log('');
  console.log('Global Options:');
  console.log('  --help, -h     Show this help');
  console.log('  --quiet, -q    Suppress server stderr');
  console.log('  --raw          Print raw MCP response');
  console.log('  --debug        Enable debug output');
  console.log('');
  if (tools.length > 0) {
    console.log('Available Tools:');
    for (const tool of tools) {
      const name = tool.name.replace(/_/g, '-');
      const desc = tool.description || 'No description';
      console.log(`  --${name.padEnd(20)} ${desc.slice(0, 50)}${desc.length > 50 ? '...' : ''}`);
    }
    console.log('');
    console.log('Examples:');
    console.log(`  mcpli --${tools[0].name.replace(/_/g, '-')} -- node server.js`);
    console.log(`  mcpli ${tools[0].name} param="value" -- node server.js`);
  } else {
    console.log('Examples:');
    console.log('  mcpli --help -- node server.js');
  }
}
async function main() {
  try {
    const { globals, childCommand, childArgs, userArgs } = parseArgs(process.argv);
    if (globals.debug) {
      console.error('[DEBUG] Args:', { childCommand, childArgs, userArgs });
    }
    // Discover tools
    const { tools, client, close } = await discoverTools(childCommand, childArgs, globals);
    if (globals.debug) {
      console.error('[DEBUG] Found tools:', tools.map((t: any) => t.name));
    }
    // Show help if requested or no tool specified
    if (globals.help || userArgs.length === 0) {
      printHelp(tools);
      await close();
      return;
    }
    // Find selected tool
    const selectedTool = findTool(userArgs, tools);
    if (!selectedTool) {
      console.error('Error: No tool specified or tool not found');
      console.error('Use --help to see available tools');
      await close();
      process.exit(1);
    }
    if (globals.debug) {
      console.error('[DEBUG] Selected tool:', selectedTool.name);
    }
    // Parse parameters
    const params = parseParams(userArgs, selectedTool);
    if (globals.debug) {
      console.error('[DEBUG] Parameters:', params);
    }
    // Execute tool
    const result = await client.callTool({
      name: selectedTool.name,
      arguments: params
    });
    await close();
    // Output result
    if (globals.raw) {
      console.log(JSON.stringify(result, null, 2));
    } else {
      const extracted = extractContent(result);
      if (extracted !== null) {
        if (typeof extracted === 'string') {
          console.log(extracted);
        } else {
          console.log(JSON.stringify(extracted, null, 2));
        }
      }
    }
  } catch (error) {
    console.error(`Error: ${error instanceof Error ? error.message : error}`);
    process.exit(1);
  }
}
main();
</file>

<file path="mcpli.ts">
#!/usr/bin/env node
/**
 * MCPLI - Turn any MCP server into a first-class CLI tool
 * 
 * This version supports both stateless mode and long-lived daemon processes.
 */
import { Client } from '@modelcontextprotocol/sdk/client/index.js';
import { StdioClientTransport } from '@modelcontextprotocol/sdk/client/stdio.js';
import { DaemonClient } from './daemon/index.js';
import { 
  handleDaemonStart, 
  handleDaemonStop, 
  handleDaemonStatus, 
  handleDaemonRestart,
  handleDaemonLogs,
  handleDaemonClean,
  printDaemonHelp
} from './daemon/index.js';
interface GlobalOptions {
  help?: boolean;
  quiet?: boolean;
  raw?: boolean;
  debug?: boolean;
  logs?: boolean;
  verbose?: boolean;
  timeout?: number;
  daemon?: boolean;
  force?: boolean;
}
function parseArgs(argv: string[]) {
  const args = argv.slice(2); // Remove node and script name
  const globals: GlobalOptions = { timeout: 30000 };
  // Check for daemon subcommand
  if (args[0] === 'daemon') {
    globals.daemon = true;
    // Check if help is requested for daemon
    if (args[1] === '--help' || args[1] === '-h') {
      globals.help = true;
      return { 
        globals, 
        daemonCommand: '',
        daemonArgs: [],
        childCommand: '',
        childArgs: [],
        userArgs: []
      };
    }
    const daemonCommand = args[1];
    const daemonArgs = args.slice(2);
    // Parse daemon-specific options
    for (const arg of daemonArgs) {
      if (arg === '--help' || arg === '-h') globals.help = true;
      else if (arg === '--debug') globals.debug = true;
      else if (arg === '--logs') globals.logs = true;
      else if (arg === '--verbose') globals.verbose = true;
      else if (arg === '--force') globals.force = true;
      else if (arg.startsWith('--timeout=')) {
        globals.timeout = parseInt(arg.split('=')[1], 10);
      }
    }
    return { 
      globals, 
      daemonCommand, 
      daemonArgs,
      childCommand: '',
      childArgs: [],
      userArgs: []
    };
  }
  // Regular tool execution mode - find the -- separator
  const dashIndex = args.indexOf('--');
  if (dashIndex === -1) {
    // For help or when no command specified, allow missing --
    if (args.includes('--help') || args.includes('-h') || args.length === 0) {
      return {
        globals: { ...globals, help: true },
        childCommand: '',
        childArgs: [],
        userArgs: args
      };
    }
    // Check if there might be a daemon running - allow daemon mode
    // In daemon mode, no -- is required as the server is already running
    return {
      globals,
      childCommand: '', // Empty means try daemon mode
      childArgs: [],
      userArgs: args
    };
  }
  const childCommand = args[dashIndex + 1];
  const childArgs = args.slice(dashIndex + 2);
  const userArgs = args.slice(0, dashIndex);
  if (!childCommand) {
    console.error('Error: Child command required after --');
    process.exit(1);
  }
  // Parse global options - but don't set help=true if there's a tool name before --help
  let foundToolName = false;
  for (const arg of userArgs) {
    if (!arg.startsWith('--') && !arg.startsWith('-') && !foundToolName) {
      foundToolName = true; // This might be a tool name
      continue;
    }
    if (arg === '--help' || arg === '-h') {
      // Only set global help if no tool name was found
      if (!foundToolName) {
        globals.help = true;
      }
    }
    else if (arg === '--quiet' || arg === '-q') globals.quiet = true;
    else if (arg === '--raw') globals.raw = true;
    else if (arg === '--debug') globals.debug = true;
    else if (arg === '--logs') globals.logs = true;
    else if (arg === '--verbose') globals.verbose = true;
    else if (arg.startsWith('--timeout=')) {
      globals.timeout = parseInt(arg.split('=')[1], 10);
    }
  }
  return { globals, childCommand, childArgs, userArgs };
}
async function discoverTools(command: string, args: string[], options: GlobalOptions) {
  // If no command provided, only try daemon mode (no fallback to stateless)
  const daemonOnly = !command;
  // Try daemon client first, with fallback to direct connection
  const daemonClient = new DaemonClient(command, args, {
    logs: options.logs || options.verbose,
    debug: options.debug,
    timeout: options.timeout,
    autoStart: !daemonOnly, // Don't auto-start if command is empty
    fallbackToStateless: !daemonOnly // No fallback if daemon-only mode
  });
  try {
    const result = await daemonClient.listTools();
    return { 
      tools: result.tools || [], 
      daemonClient,
      isDaemon: true,
      close: () => Promise.resolve()
    };
  } catch (error) {
    // If daemon-only mode (no command), don't try direct connection
    if (daemonOnly) {
      throw error;
    }
    // Fallback to direct connection
    if (options.debug) {
      console.error('[DEBUG] Daemon failed, using direct connection:', error);
    }
    const transport = new StdioClientTransport({
      command,
      args,
      stderr: (options.logs || options.verbose) ? 'inherit' : 'ignore'
    });
    const client = new Client({
      name: 'mcpli',
      version: '1.0.0'
    }, {
      capabilities: {}
    });
    try {
      await client.connect(transport);
      const result = await client.listTools();
      return { 
        tools: result.tools || [], 
        client, 
        isDaemon: false,
        close: () => client.close() 
      };
    } catch (error) {
      throw new Error(`Failed to connect to MCP server: ${error instanceof Error ? error.message : error}`);
    }
  }
}
function normalizeToolName(name: string): string {
  return name.toLowerCase().replace(/[^a-z0-9]/g, '');
}
function findTool(userArgs: string[], tools: any[]) {
  const toolMap = new Map();
  // Build tool index
  for (const tool of tools) {
    const name = tool.name;
    toolMap.set(name, tool);
    toolMap.set(name.replace(/_/g, '-'), tool);
    toolMap.set(normalizeToolName(name), tool);
  }
  // Look for tool selection - first non-option argument is the tool name
  for (const arg of userArgs) {
    if (!arg.startsWith('--') && !arg.startsWith('-')) {
      if (toolMap.has(arg)) {
        return { tool: toolMap.get(arg), toolName: arg };
      }
    }
  }
  return null;
}
function parseParams(userArgs: string[], selectedTool: any, toolName: string): Record<string, any> {
  const params: Record<string, any> = {};
  const schema = selectedTool.inputSchema?.properties || {};
  // Find the start of parameters for the selected tool
  const toolNameIndex = userArgs.indexOf(toolName);
  if (toolNameIndex === -1) {
    // This should not happen if findTool worked correctly, but as a safeguard.
    return {};
  }
  const paramArgs = userArgs.slice(toolNameIndex + 1);
  const args: { key: string, value: string | boolean }[] = [];
  // Phase 1: Tokenize arguments into a structured list of key-value pairs
  for (let i = 0; i < paramArgs.length; i++) {
    const arg = paramArgs[i];
    let key: string | undefined;
    let value: string | boolean | undefined;
    if (arg.startsWith('--')) {
      if (arg.includes('=')) {
        const parts = arg.split('=', 2);
        key = parts[0].slice(2);
        value = parts[1];
      } else {
        key = arg.slice(2);
        const nextArg = paramArgs[i + 1];
        if (nextArg && (!nextArg.startsWith('-') || !isNaN(Number(nextArg)))) {
          value = nextArg;
          i++; // Consume value argument
        } else {
          value = true; // It's a boolean flag
        }
      }
    } else if (arg.startsWith('-') && arg.length === 2 && isNaN(Number(arg[1]))) {
      // Handle short-form arguments like -f (but not negative numbers like -5)
      key = arg.slice(1);
      const nextArg = paramArgs[i + 1];
      if (nextArg && (!nextArg.startsWith('-') || !isNaN(Number(nextArg)))) {
        value = nextArg;
        i++; // Consume value argument
      } else {
        value = true; // It's a boolean flag
      }
    }
    if (key !== undefined && value !== undefined) {
      args.push({ key, value });
    }
    // Non-option arguments (positional) are ignored for now
  }
  // Phase 2: Parse and convert values based on the tool's inputSchema
  for (const { key, value } of args) {
    const propSchema = schema[key];
    if (!propSchema) {
      // If no schema is found for this param, make a best effort to parse
      if (value === true) {
        params[key] = true;
      } else {
        try {
          params[key] = JSON.parse(value as string);
        } catch {
          params[key] = value;
        }
      }
      continue;
    }
    // Handle boolean type specifically, as it can be a flag or have a value
    if (propSchema.type === 'boolean') {
      if (value === true) {
        params[key] = true;
        continue;
      }
      const strValue = String(value).toLowerCase();
      if (strValue === 'true') {
        params[key] = true;
      } else if (strValue === 'false') {
        params[key] = false;
      } else {
        throw new Error(`Argument --${key} expects a boolean (true/false), but received "${value}".`);
      }
      continue;
    }
    // For all other types, a valueless flag is an error
    if (value === true) {
      throw new Error(`Argument --${key} of type "${propSchema.type}" requires a value.`);
    }
    const strValue = value as string;
    switch (propSchema.type) {
      case 'string':
        params[key] = strValue;
        break;
      case 'number':
      case 'integer':
        const num = Number(strValue);
        if (isNaN(num) || strValue.trim() === '') {
          throw new Error(`Argument --${key} expects a ${propSchema.type}, but received "${strValue}".`);
        }
        if (propSchema.type === 'integer' && !Number.isInteger(num)) {
          throw new Error(`Argument --${key} expects an integer, but received "${strValue}".`);
        }
        params[key] = num;
        break;
      case 'array':
      case 'object':
        try {
          params[key] = JSON.parse(strValue);
        } catch (e) {
          throw new Error(`Argument --${key} expects a valid JSON ${propSchema.type}. Parse error: ${e instanceof Error ? e.message : String(e)} on input: "${strValue}"`);
        }
        break;
      case 'null':
        if (strValue.toLowerCase() !== 'null') {
          throw new Error(`Argument --${key} expects null, but received "${strValue}".`);
        }
        params[key] = null;
        break;
      default:
        // Fallback for schemas with anyOf, oneOf, or no type property.
        try {
          params[key] = JSON.parse(strValue);
        } catch {
          params[key] = strValue;
        }
    }
  }
  return params;
}
function extractContent(result: any): any {
  if (!result.content || result.content.length === 0) {
    return null;
  }
  if (result.content.length === 1) {
    const item = result.content[0];
    if (item.type === 'text') {
      try {
        return JSON.parse(item.text);
      } catch {
        return item.text;
      }
    }
    return item;
  }
  return result.content.map((item: any) => {
    if (item.type === 'text') {
      try {
        return JSON.parse(item.text);
      } catch {
        return item.text;
      }
    }
    return item;
  });
}
function printHelp(tools: any[], specificTool?: any) {
  if (specificTool) {
    printToolHelp(specificTool);
    return;
  }
  console.log('MCPLI - Turn any MCP server into a first-class CLI tool');
  console.log('');
  console.log('Usage:');
  console.log('  mcpli <tool> [tool-options...] -- <mcp-server-command> [args...]');
  console.log('  mcpli <tool> --help -- <mcp-server-command> [args...]');
  console.log('  mcpli --help -- <mcp-server-command> [args...]');
  console.log('  mcpli daemon <subcommand> [options]');
  console.log('');
  console.log('Global Options:');
  console.log('  --help, -h     Show this help and list all available tools');
  console.log('  --verbose      Show MCP server output (stderr/logs)');
  console.log('  --raw          Print raw MCP response');
  console.log('  --debug        Enable debug output');
  console.log('  --timeout=<ms> Set daemon timeout (default: 30000)');
  console.log('');
  console.log('Daemon Commands:');
  console.log('  daemon start   Start long-lived daemon process');
  console.log('  daemon stop    Stop daemon process');
  console.log('  daemon status  Show daemon status');
  console.log('  daemon restart Restart daemon process');
  console.log('  daemon logs    Show daemon logs');
  console.log('  daemon clean   Clean up daemon files');
  console.log('');
  if (tools.length > 0) {
    console.log('Available Tools:');
    for (const tool of tools) {
      const name = tool.name.replace(/_/g, '-');
      const desc = tool.description || 'No description';
      console.log(`  ${name.padEnd(20)} ${desc.slice(0, 60)}${desc.length > 60 ? '...' : ''}`);
    }
    console.log('');
    console.log('Tool Help:');
    console.log(`  mcpli <tool> --help -- <mcp-server-command>    Show detailed help for specific tool`);
    console.log('');
    console.log('Examples:');
    console.log(`  mcpli ${tools[0].name.replace(/_/g, '-')} --help -- node server.js`);
    console.log(`  mcpli ${tools[0].name.replace(/_/g, '-')} --option value -- node server.js`);
    console.log('');
    console.log('Fast Execution (via auto-daemon):');
    console.log(`  mcpli ${tools[0].name.replace(/_/g, '-')} --option value  # No MCP server command needed after first use`);
  } else {
    console.log('No tools found. The MCP server may not be responding correctly.');
    console.log('');
    console.log('Examples:');
    console.log('  mcpli --help -- node server.js       # Show tools from server.js');
    console.log('  mcpli daemon start -- node server.js # Start long-lived daemon');
  }
}
function printToolHelp(tool: any) {
  console.log(`MCPLI Tool: ${tool.name}`);
  console.log('');
  if (tool.description) {
    console.log(`Description: ${tool.description}`);
    console.log('');
  }
  console.log(`Usage: mcpli ${tool.name} [options] -- <mcp-server-command> [args...]`);
  console.log('');
  if (tool.inputSchema && tool.inputSchema.properties) {
    console.log('Options:');
    const properties = tool.inputSchema.properties;
    const required = tool.inputSchema.required || [];
    for (const [propName, propSchema] of Object.entries(properties)) {
      const schema = propSchema as any;
      const isRequired = required.includes(propName);
      const type = schema.type || 'string';
      const description = schema.description || '';
      const defaultValue = schema.default;
      let line = `  --${propName.padEnd(20)}`;
      if (type) line += ` (${type})`;
      if (isRequired) line += ' [required]';
      if (description) line += ` ${description}`;
      if (defaultValue !== undefined) line += ` (default: ${JSON.stringify(defaultValue)})`;
      console.log(line);
    }
    console.log('');
  }
  console.log('Examples:');
  const exampleName = tool.name.replace(/_/g, '-');
  console.log(`  mcpli ${exampleName} --help -- node server.js`);
  if (tool.inputSchema && tool.inputSchema.properties) {
    const properties = Object.keys(tool.inputSchema.properties);
    if (properties.length > 0) {
      const firstProp = properties[0];
      console.log(`  mcpli ${exampleName} --${firstProp} "example-value" -- node server.js`);
    }
  }
}
async function main() {
  try {
    const result = parseArgs(process.argv);
    const { globals } = result;
    if (globals.debug) {
      console.error('[DEBUG] Parsed args:', result);
    }
    // Handle daemon subcommands
    if (globals.daemon) {
      const { daemonCommand, daemonArgs } = result as any;
      if (globals.help || !daemonCommand) {
        printDaemonHelp();
        return;
      }
      const options = {
        debug: globals.debug,
        logs: globals.logs || globals.verbose,
        force: globals.force,
        timeout: globals.timeout
      };
      switch (daemonCommand) {
        case 'start':
          const dashIndex = daemonArgs.indexOf('--');
          if (dashIndex === -1) {
            console.error('Error: Command required after -- for daemon start');
            console.error('Usage: mcpli daemon start -- <command> [args...]');
            process.exit(1);
          }
          const command = daemonArgs[dashIndex + 1];
          const args = daemonArgs.slice(dashIndex + 2);
          if (!command) {
            console.error('Error: Command required after --');
            process.exit(1);
          }
          await handleDaemonStart(command, args, options);
          break;
        case 'stop':
          await handleDaemonStop(options);
          break;
        case 'status':
          await handleDaemonStatus(options);
          break;
        case 'restart':
          const restartDashIndex = daemonArgs.indexOf('--');
          if (restartDashIndex === -1) {
            console.error('Error: Command required after -- for daemon restart');
            console.error('Usage: mcpli daemon restart -- <command> [args...]');
            process.exit(1);
          }
          const restartCommand = daemonArgs[restartDashIndex + 1];
          const restartArgs = daemonArgs.slice(restartDashIndex + 2);
          if (!restartCommand) {
            console.error('Error: Command required after --');
            process.exit(1);
          }
          await handleDaemonRestart(restartCommand, restartArgs, options);
          break;
        case 'logs':
          await handleDaemonLogs(options);
          break;
        case 'clean':
          await handleDaemonClean(options);
          break;
        default:
          console.error(`Error: Unknown daemon command: ${daemonCommand}`);
          console.error('Use "mcpli daemon --help" to see available commands');
          process.exit(1);
      }
      return;
    }
    // Regular tool execution mode
    const { childCommand, childArgs, userArgs } = result;
    // No error for missing childCommand - we'll try daemon mode first
    // Show help for regular mode
    if (globals.help) {
      if (childCommand) {
        // Get tools to show in help - always discover tools for root help
        try {
          const { tools, close } = await discoverTools(childCommand, childArgs, globals);
          printHelp(tools);
          await close();
        } catch (error) {
          console.error(`Error connecting to MCP server: ${error instanceof Error ? error.message : error}`);
          console.error('Cannot show available tools. Please check your MCP server command.');
          printHelp([]);
        }
      } else {
        // Try daemon mode for help - discover tools from running daemon
        try {
          const { tools, close } = await discoverTools('', [], globals);
          printHelp(tools);
          await close();
        } catch (error) {
          console.error('Error: No daemon running and MCP server command not provided');
          console.error('Usage: mcpli --help -- <mcp-server-command> [args...]');
          console.error('Example: mcpli --help -- node server.js');
          printHelp([]);
        }
      }
      return;
    }
    if (globals.debug) {
      console.error('[DEBUG] Tool execution mode:', { childCommand, childArgs, userArgs });
    }
    // Discover tools
    const { tools, client, daemonClient, isDaemon, close } = await discoverTools(childCommand, childArgs, globals);
    if (globals.debug) {
      console.error('[DEBUG] Found tools:', tools.map((t: any) => t.name));
      console.error('[DEBUG] Using daemon:', isDaemon);
    }
    // Show help if no tool specified
    if (userArgs.length === 0) {
      printHelp(tools);
      await close();
      return;
    }
    // Find selected tool
    const toolResult = findTool(userArgs, tools);
    if (!toolResult) {
      console.error('Error: No tool specified or tool not found');
      console.error('Available tools:', tools.map((t: any) => t.name.replace(/_/g, '-')).join(', '));
      console.error('Use --help to see all available tools');
      await close();
      process.exit(1);
    }
    const { tool: selectedTool, toolName } = toolResult;
    // Check for tool-specific help
    const hasHelp = userArgs.some((arg: string) => arg === '--help' || arg === '-h');
    if (hasHelp) {
      printHelp(tools, selectedTool);
      await close();
      return;
    }
    if (globals.debug) {
      console.error('[DEBUG] Selected tool:', selectedTool.name);
      console.error('[DEBUG] Tool name used:', toolName);
    }
    // Parse parameters
    const params = parseParams(userArgs, selectedTool, toolName);
    if (globals.debug) {
      console.error('[DEBUG] Parameters:', params);
    }
    // Execute tool using appropriate client
    let executionResult;
    if (isDaemon && daemonClient) {
      executionResult = await daemonClient.callTool({
        name: selectedTool.name,
        arguments: params
      });
    } else if (client) {
      executionResult = await client.callTool({
        name: selectedTool.name,
        arguments: params
      });
    } else {
      throw new Error('No client available for tool execution');
    }
    await close();
    // Output result
    if (globals.raw) {
      console.log(JSON.stringify(executionResult, null, 2));
    } else {
      const extracted = extractContent(executionResult);
      if (extracted !== null) {
        if (typeof extracted === 'string') {
          console.log(extracted);
        } else {
          console.log(JSON.stringify(extracted, null, 2));
        }
      }
    }
  } catch (error) {
    console.error(`Error: ${error instanceof Error ? error.message : error}`);
    process.exit(1);
  }
}
main();
</file>

</files>
</file>

<file path="complex-test-server.js">
#!/usr/bin/env node
import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import { 
  ListToolsRequestSchema, 
  CallToolRequestSchema
} from '@modelcontextprotocol/sdk/types.js';
const server = new Server(
  {
    name: 'complex-test-server',
    version: '1.0.0',
  },
  {
    capabilities: {
      tools: {},
    },
  }
);
// Test tool with comprehensive JSON Schema data types
server.setRequestHandler(ListToolsRequestSchema, async () => {
  return {
    tools: [
      {
        name: 'test_all_types',
        description: 'Test tool with all JSON Schema data types',
        inputSchema: {
          type: 'object',
          properties: {
            // Primitive types
            text: { type: 'string', description: 'A string value' },
            count: { type: 'integer', description: 'An integer value' },
            rating: { type: 'number', description: 'A decimal number' },
            enabled: { type: 'boolean', description: 'A boolean flag' },
            empty: { type: 'null', description: 'A null value' },
            // Array types
            tags: { 
              type: 'array', 
              items: { type: 'string' },
              description: 'Array of strings' 
            },
            scores: { 
              type: 'array', 
              items: { type: 'number' },
              description: 'Array of numbers' 
            },
            // Object types
            config: {
              type: 'object',
              properties: {
                timeout: { type: 'number' },
                retries: { type: 'integer' },
                debug: { type: 'boolean' }
              },
              description: 'Configuration object'
            },
            // Complex nested object
            metadata: {
              type: 'object',
              properties: {
                user: {
                  type: 'object',
                  properties: {
                    id: { type: 'integer' },
                    name: { type: 'string' },
                    preferences: {
                      type: 'array',
                      items: { type: 'string' }
                    }
                  }
                },
                timestamps: {
                  type: 'array',
                  items: { type: 'number' }
                }
              },
              description: 'Complex nested metadata'
            }
          },
          required: ['text', 'count']
        }
      }
    ]
  };
});
server.setRequestHandler(CallToolRequestSchema, async (request) => {
  const { name, arguments: args } = request.params;
  if (name === 'test_all_types') {
    return {
      content: [
        {
          type: 'text',
          text: `Received arguments: ${JSON.stringify(args, null, 2)}\n\nArgument types:\n${Object.entries(args).map(([key, value]) => `${key}: ${typeof value} (${value === null ? 'null' : Array.isArray(value) ? 'array' : typeof value})`).join('\n')}`
        }
      ]
    };
  }
  throw new Error(`Unknown tool: ${name}`);
});
async function main() {
  const transport = new StdioServerTransport();
  await server.connect(transport);
}
main().catch(console.error);
</file>

<file path=".claude/settings.local.json">
{
  "permissions": {
    "allow": [
      "mcp__RepoPrompt__manage_selection",
      "mcp__RepoPrompt__chat_send",
      "Bash(vibe-tools:*)"
    ],
    "additionalDirectories": [
      "/Volumes/Developer/mcpli"
    ]
  }
}
</file>

<file path="src/daemon/client.ts">
import { isDaemonRunning, getDaemonInfo, updateLastAccess, generateDaemonId } from './lock.js';
import { sendIPCRequest, generateRequestId, testIPCConnection } from './ipc.js';
import { startDaemon, DaemonOptions } from './spawn.js';
export interface DaemonClientOptions extends DaemonOptions {
  autoStart?: boolean;
  fallbackToStateless?: boolean;
}
export class DaemonClient {
  private daemonId?: string;
  constructor(
    private command: string,
    private args: string[],
    private options: DaemonClientOptions = {}
  ) {
    this.options = {
      autoStart: true,
      fallbackToStateless: true,
      ...options
    };
    // Compute daemonId only when we have a command (daemon discovery mode may not provide one)
    if (this.command && this.command.trim()) {
      this.daemonId = generateDaemonId(this.command, this.args);
    }
  }
  async listTools(): Promise<any> {
    try {
      const result = await this.callDaemon('listTools');
      return result;
    } catch (error) {
      if (this.options.fallbackToStateless) {
        if (this.options.debug) {
          console.error('[DEBUG] Daemon listTools failed, falling back to stateless:', error);
        }
        return this.fallbackListTools();
      }
      throw error;
    }
  }
  async callTool(params: { name: string; arguments: any }): Promise<any> {
    try {
      const result = await this.callDaemon('callTool', params);
      return result;
    } catch (error) {
      if (this.options.fallbackToStateless) {
        if (this.options.debug) {
          console.error('[DEBUG] Daemon callTool failed, falling back to stateless:', error);
        }
        return this.fallbackCallTool(params);
      }
      throw error;
    }
  }
  private async callDaemon(method: string, params?: any): Promise<any> {
    const cwd = this.options.cwd || process.cwd();
    // Check if daemon is running (for this specific daemonId, if any)
    const isRunning = await isDaemonRunning(cwd, this.daemonId);
    if (!isRunning) {
      if (this.options.autoStart && this.command) {
        if (this.options.debug) {
          console.error('[DEBUG] Starting daemon automatically');
        }
        await this.startDaemon();
      } else {
        throw new Error(this.command ? 'Daemon not running and auto-start disabled' : 'No daemon running and no server command provided');
      }
    }
    // Get daemon info
    const daemonInfo = await getDaemonInfo(cwd, this.daemonId);
    if (!daemonInfo) {
      throw new Error('Daemon info not available');
    }
    // Test connection
    if (!(await testIPCConnection(daemonInfo))) {
      throw new Error('Cannot connect to daemon IPC socket');
    }
    // Send request
    const request = {
      id: generateRequestId(),
      method: method as 'listTools' | 'callTool' | 'ping',
      params
    };
    const result = await sendIPCRequest(daemonInfo.socket, request);
    // Update last access time
    await updateLastAccess(cwd, this.daemonId);
    return result;
  }
  private async startDaemon(): Promise<void> {
    try {
      await startDaemon(this.command, this.args, { ...this.options, daemonId: this.daemonId });
      // Wait a moment for daemon to be fully ready
      await new Promise(resolve => setTimeout(resolve, 100));
      if (this.options.debug) {
        console.error('[DEBUG] Daemon started successfully');
      }
    } catch (error) {
      if (this.options.debug) {
        console.error('[DEBUG] Failed to start daemon:', error);
      }
      throw new Error(`Failed to start daemon: ${error instanceof Error ? error.message : error}`);
    }
  }
  private async fallbackListTools(): Promise<any> {
    const { Client } = await import('@modelcontextprotocol/sdk/client/index.js');
    const { StdioClientTransport } = await import('@modelcontextprotocol/sdk/client/stdio.js');
    const transport = new StdioClientTransport({
      command: this.command,
      args: this.args,
      stderr: this.options.logs ? 'inherit' : 'ignore'
    });
    const client = new Client({
      name: 'mcpli',
      version: '1.0.0'
    }, {
      capabilities: {}
    });
    try {
      await client.connect(transport);
      const result = await client.listTools();
      await client.close();
      return result;
    } catch (error) {
      await client.close();
      throw error;
    }
  }
  private async fallbackCallTool(params: { name: string; arguments: any }): Promise<any> {
    const { Client } = await import('@modelcontextprotocol/sdk/client/index.js');
    const { StdioClientTransport } = await import('@modelcontextprotocol/sdk/client/stdio.js');
    const transport = new StdioClientTransport({
      command: this.command,
      args: this.args,
      stderr: this.options.logs ? 'inherit' : 'ignore'
    });
    const client = new Client({
      name: 'mcpli',
      version: '1.0.0'
    }, {
      capabilities: {}
    });
    try {
      await client.connect(transport);
      const result = await client.callTool(params);
      await client.close();
      return result;
    } catch (error) {
      await client.close();
      throw error;
    }
  }
  async ping(): Promise<boolean> {
    try {
      const result = await this.callDaemon('ping');
      return result === 'pong';
    } catch {
      return false;
    }
  }
}
// Convenience function for one-off operations
export async function withDaemonClient<T>(
  command: string,
  args: string[],
  options: DaemonClientOptions,
  operation: (client: DaemonClient) => Promise<T>
): Promise<T> {
  const client = new DaemonClient(command, args, options);
  return await operation(client);
}
</file>

<file path="src/daemon/commands.ts">
import { 
  isDaemonRunning, 
  getDaemonInfo, 
  stopDaemon, 
  cleanupStaleLock,
  listAllDaemons,
  cleanupAllStaleDaemons,
  generateDaemonId,
  normalizeCommand
} from './lock.js';
import { startDaemon, DaemonOptions } from './spawn.js';
import { testIPCConnection } from './ipc.js';
import fs from 'fs/promises';
import path from 'path';
export interface DaemonCommandOptions extends DaemonOptions {
  force?: boolean;
}
// Utility: compute daemonId from a command + args using the same normalization as the lock layer
function computeDaemonIdFromCommand(command?: string, args: string[] = []): string | undefined {
  if (!command || !command.trim()) return undefined;
  const norm = normalizeCommand(command, args);
  return generateDaemonId(norm.command, norm.args);
}
// Utility: friendlier string for command+args
function formatCommand(command?: string, args: string[] = []): string {
  if (!command) return '(no command)';
  return [command, ...args].join(' ');
}
// Utility: normalize entries from listAllDaemons() into ids
function extractDaemonIds(entries: any[]): string[] {
  if (!Array.isArray(entries)) return [];
  const ids = entries
    .map((d: any) => {
      if (typeof d === 'string') return d;
      if (d && typeof d === 'object' && typeof d.id === 'string') return d.id;
      return undefined;
    })
    .filter((v: any): v is string => typeof v === 'string');
  return Array.from(new Set(ids));
}
// Utility: attempt to kill daemon by id, with graceful then forceful fallback
async function killDaemonById(cwd: string, daemonId: string): Promise<{ killed: boolean; reason?: string }> {
  try {
    const info = await getDaemonInfo(cwd, daemonId);
    if (!info || typeof info.pid !== 'number') {
      return { killed: false, reason: 'no pid in daemon info' };
    }
    const runningBefore = await isDaemonRunning(cwd, daemonId);
    if (!runningBefore) {
      return { killed: false, reason: 'not running' };
    }
    try {
      process.kill(info.pid, 'SIGTERM');
    } catch (err: any) {
      if (!err || err.code !== 'ESRCH') {
        return { killed: false, reason: `SIGTERM failed: ${err?.message || String(err)}` };
      }
      // If ESRCH, process already gone; proceed to cleanup
    }
    // Give it a moment to exit gracefully
    await new Promise(resolve => setTimeout(resolve, 500));
    const stillRunning = await isDaemonRunning(cwd, daemonId).catch(() => false);
    if (!stillRunning) {
      return { killed: true };
    }
    // Force kill
    try {
      process.kill(info.pid, 'SIGKILL');
    } catch (err: any) {
      if (!err || err.code !== 'ESRCH') {
        return { killed: false, reason: `SIGKILL failed: ${err?.message || String(err)}` };
      }
    }
    await new Promise(resolve => setTimeout(resolve, 250));
    return { killed: true };
  } finally {
    await cleanupAllStaleDaemons(cwd).catch(() => {});
  }
}
export async function handleDaemonStart(
  command: string, 
  args: string[], 
  options: DaemonCommandOptions = {}
): Promise<void> {
  const cwd = options.cwd || process.cwd();
  const daemonId = computeDaemonIdFromCommand(command, args);
  // Check if daemon is already running for this specific command
  if (daemonId && await isDaemonRunning(cwd, daemonId)) {
    const info = await getDaemonInfo(cwd, daemonId);
    console.log(`Daemon is already running for this command (PID ${info?.pid})`);
    return;
  }
  try {
    console.log(`Starting daemon: ${command} ${args.join(' ')}`);
    const daemon = await startDaemon(command, args, options);
    console.log(`Daemon started successfully (PID ${daemon.lock.info.pid})`);
    console.log(`Socket: ${daemon.lock.info.socket}`);
    if (options.debug) {
      console.log('Debug mode enabled - daemon will log to console');
    }
  } catch (error) {
    console.error(`Failed to start daemon: ${error instanceof Error ? error.message : error}`);
    process.exit(1);
  }
}
export async function handleDaemonStop(
  command?: string,
  args: string[] = [],
  options: DaemonCommandOptions = {}
): Promise<void> {
  const cwd = options.cwd || process.cwd();
  try {
    let targetIds: string[] = [];
    const daemonId = computeDaemonIdFromCommand(command, args);
    if (daemonId) {
      targetIds = [daemonId];
    } else {
      // Stop all daemons if no specific command provided
      const entries = await listAllDaemons(cwd);
      targetIds = extractDaemonIds(entries);
    }
    if (targetIds.length === 0) {
      console.log('No daemons found');
      return;
    }
    let stopped = 0;
    for (const id of targetIds) {
      const result = await killDaemonById(cwd, id);
      if (result.killed) {
        stopped++;
        console.log(`Stopped daemon ${id}`);
      } else {
        console.log(`Skipped daemon ${id}${result.reason ? ` (${result.reason})` : ''}`);
      }
    }
    console.log(`Done. ${stopped} daemon(s) stopped.`);
  } catch (error) {
    console.error(`Failed to stop daemon: ${error instanceof Error ? error.message : error}`);
    process.exit(1);
  }
}
export async function handleDaemonStatus(options: DaemonCommandOptions = {}): Promise<void> {
  const cwd = options.cwd || process.cwd();
  try {
    const entries = await listAllDaemons(cwd);
    const ids = extractDaemonIds(entries);
    if (ids.length === 0) {
      console.log('No daemons found in this directory');
      return;
    }
    let anyRunning = false;
    for (const id of ids) {
      const running = await isDaemonRunning(cwd, id);
      if (running) {
        anyRunning = true;
        const info = await getDaemonInfo(cwd, id).catch(() => null);
        const cmd = info?.command;
        const args = Array.isArray(info?.args) ? info.args : [];
        const pid = info?.pid;
        const started = info?.started ? new Date(info.started).toLocaleString() : 'unknown';
        const lastAccess = info?.lastAccess ? new Date(info.lastAccess).toLocaleString() : 'unknown';
        const canConnect = info ? await testIPCConnection(info) : false;
        console.log(`Daemon ${id}:`);
        console.log(`  Status: Running`);
        console.log(`  PID: ${pid ?? 'unknown'}`);
        console.log(`  Command: ${formatCommand(cmd, args)}`);
        console.log(`  Started: ${started}`);
        console.log(`  Last access: ${lastAccess}`);
        console.log(`  Socket: ${info?.socket ?? 'unknown'}`);
        console.log(`  IPC connection: ${canConnect ? 'OK' : 'FAILED'}`);
        if (info?.started) {
          const uptimeMs = Date.now() - new Date(info.started).getTime();
          const uptimeMinutes = Math.floor(uptimeMs / 60000);
          const uptimeHours = Math.floor(uptimeMinutes / 60);
          const uptimeDays = Math.floor(uptimeHours / 24);
          let uptimeStr = '';
          if (uptimeDays > 0) uptimeStr += `${uptimeDays}d `;
          if (uptimeHours > 0) uptimeStr += `${uptimeHours % 24}h `;
          uptimeStr += `${uptimeMinutes % 60}m`;
          console.log(`  Uptime: ${uptimeStr}`);
        }
        console.log('');
      }
    }
    if (!anyRunning) {
      console.log('No running daemons found');
    }
  } catch (error) {
    console.error(`Error reading daemon status: ${error instanceof Error ? error.message : error}`);
    process.exit(1);
  }
}
export async function handleDaemonRestart(
  command?: string,
  args: string[] = [],
  options: DaemonCommandOptions = {}
): Promise<void> {
  console.log('Restarting daemon...');
  // Stop existing daemon(s) - if command provided, stop specific daemon; otherwise stop all
  await handleDaemonStop(command, args, options);
  // Wait a moment for cleanup
  await new Promise(resolve => setTimeout(resolve, 500));
  // For restart with a specific command, start that daemon
  if (command) {
    await handleDaemonStart(command, args, options);
  } else {
    console.log('No specific command provided. Daemons will auto-start when commands are run.');
  }
}
export async function handleDaemonLogs(options: DaemonCommandOptions = {}): Promise<void> {
  const cwd = options.cwd || process.cwd();
  const logPath = path.join(cwd, '.mcpli', 'daemon.log');
  try {
    const logContent = await fs.readFile(logPath, 'utf8');
    console.log(logContent);
  } catch (error) {
    if ((error as any).code === 'ENOENT') {
      console.log('No log file found. Daemon may not have been started with --logs flag.');
    } else {
      console.error(`Failed to read log file: ${error instanceof Error ? error.message : error}`);
    }
  }
}
export async function handleDaemonClean(options: DaemonCommandOptions = {}): Promise<void> {
  const cwd = options.cwd || process.cwd();
  const mcpliDir = path.join(cwd, '.mcpli');
  try {
    // Stop all running daemons first
    const entries = await listAllDaemons(cwd);
    const ids = extractDaemonIds(entries);
    let stopped = 0;
    for (const id of ids) {
      const result = await killDaemonById(cwd, id);
      if (result.killed) {
        stopped++;
        console.log(`Stopped daemon ${id}`);
      }
    }
    if (stopped > 0) {
      console.log(`Stopped ${stopped} daemon(s)`);
    }
    // Remove stale lock files and metadata
    await cleanupAllStaleDaemons(cwd).catch(() => {});
    // Remove orphaned sockets
    let dirEntries: string[] = [];
    try {
      dirEntries = await fs.readdir(mcpliDir);
    } catch {
      // Missing directory is fine
      console.log('Daemon cleanup complete');
      return;
    }
    const socketFiles = dirEntries.filter((f) => /^daemon-.+\.sock$/.test(f));
    let socketsRemoved = 0;
    for (const sockName of socketFiles) {
      const idMatch = /^daemon-(.+)\.sock$/.exec(sockName);
      const daemonId = idMatch?.[1];
      if (!daemonId) continue;
      const running = await isDaemonRunning(cwd, daemonId).catch(() => false);
      if (!running) {
        const sockPath = path.join(mcpliDir, sockName);
        try {
          await fs.unlink(sockPath);
          socketsRemoved++;
          console.log(`Removed stale socket ${sockName}`);
        } catch {
          // ignore unlink errors
        }
      }
    }
    // Remove .mcpli directory if empty
    try {
      await fs.rmdir(mcpliDir);
      console.log('Removed empty .mcpli directory');
    } catch {
      // Directory not empty or doesn't exist
    }
    console.log('Daemon cleanup complete');
  } catch (error) {
    console.error(`Failed to clean daemon files: ${error instanceof Error ? error.message : error}`);
    process.exit(1);
  }
}
export function printDaemonHelp(): void {
  console.log('MCPLI Daemon Management');
  console.log('');
  console.log('Usage:');
  console.log('  mcpli daemon <command> [options]');
  console.log('');
  console.log('Commands:');
  console.log('  start [-- command args...]       Start daemon with MCP server command');
  console.log('  stop [-- command args...]        Stop specific daemon or all daemons');
  console.log('  restart [-- command args...]     Restart specific daemon or all daemons');
  console.log('  status                           Show all running daemons');
  console.log('  logs                             Show daemon log output');
  console.log('  clean                            Clean up all daemon files');
  console.log('');
  console.log('Options:');
  console.log('  --force                          Force stop daemon');
  console.log('  --logs                           Enable daemon logging');
  console.log('  --debug                          Enable debug output');
  console.log('  --timeout <ms>                   Set daemon inactivity timeout');
  console.log('');
  console.log('Notes:');
  console.log('  - Daemons are command-specific per directory using stable daemon IDs');
  console.log('  - Commands auto-start daemons transparently (no manual start needed)');
  console.log('  - stop/restart without command acts on all daemons in directory');
  console.log('');
  console.log('Examples:');
  console.log('  mcpli daemon start -- node server.js');
  console.log('  mcpli daemon status');
  console.log('  mcpli daemon stop');
  console.log('  mcpli daemon clean');
}
</file>

<file path="src/daemon/index.ts">
// Daemon management exports
export * from './lock.js';
export * from './ipc.js';
export * from './spawn.js';
export * from './client.js';
export * from './commands.js';
</file>

<file path="src/daemon/ipc.ts">
import net from 'net';
import path from 'path';
import { DaemonInfo } from './lock.js';
export interface IPCRequest {
  id: string;
  method: 'listTools' | 'callTool' | 'ping';
  params?: any;
}
export interface IPCResponse {
  id: string;
  result?: any;
  error?: string;
}
export interface IPCServer {
  server: net.Server;
  close: () => Promise<void>;
}
export async function createIPCServer(
  socketPath: string,
  handler: (request: IPCRequest) => Promise<any>
): Promise<IPCServer> {
  // Remove existing socket file if it exists
  try {
    await import('fs/promises').then(fs => fs.unlink(socketPath));
  } catch {
    // Socket file doesn't exist, which is fine
  }
  const server = net.createServer((client) => {
    let buffer = '';
    client.on('data', async (data) => {
      buffer += data.toString();
      // Handle multiple JSON messages in buffer
      while (true) {
        const newlineIndex = buffer.indexOf('\n');
        if (newlineIndex === -1) break;
        const message = buffer.slice(0, newlineIndex);
        buffer = buffer.slice(newlineIndex + 1);
        if (!message.trim()) continue;
        try {
          const request: IPCRequest = JSON.parse(message);
          const result = await handler(request);
          const response: IPCResponse = { id: request.id, result };
          client.write(JSON.stringify(response) + '\n');
        } catch (error) {
          const response: IPCResponse = {
            id: 'unknown',
            error: error instanceof Error ? error.message : String(error)
          };
          client.write(JSON.stringify(response) + '\n');
        }
      }
    });
    client.on('error', (error) => {
      console.error('IPC client error:', error);
    });
  });
  return new Promise((resolve, reject) => {
    server.listen(socketPath, () => {
      resolve({
        server,
        close: () => new Promise((resolve) => {
          server.close(() => {
            // Clean up socket file
            import('fs/promises').then(fs => 
              fs.unlink(socketPath).catch(() => {})
            ).finally(resolve);
          });
        })
      });
    });
    server.on('error', reject);
  });
}
export async function sendIPCRequest(
  socketPath: string,
  request: IPCRequest,
  timeoutMs = 10000
): Promise<any> {
  return new Promise((resolve, reject) => {
    const client = net.connect(socketPath, () => {
      client.write(JSON.stringify(request) + '\n');
    });
    let buffer = '';
    const timeout = setTimeout(() => {
      client.destroy();
      reject(new Error(`IPC request timeout after ${timeoutMs}ms`));
    }, timeoutMs);
    client.on('data', (data) => {
      buffer += data.toString();
      const newlineIndex = buffer.indexOf('\n');
      if (newlineIndex !== -1) {
        const message = buffer.slice(0, newlineIndex);
        clearTimeout(timeout);
        client.end();
        try {
          const response: IPCResponse = JSON.parse(message);
          if (response.error) {
            reject(new Error(response.error));
          } else {
            resolve(response.result);
          }
        } catch (error) {
          reject(new Error(`Invalid IPC response: ${error}`));
        }
      }
    });
    client.on('error', (error) => {
      clearTimeout(timeout);
      reject(error);
    });
    client.on('timeout', () => {
      clearTimeout(timeout);
      client.destroy();
      reject(new Error('IPC connection timeout'));
    });
  });
}
export async function testIPCConnection(daemonInfo: DaemonInfo): Promise<boolean> {
  try {
    const request: IPCRequest = {
      id: Date.now().toString(),
      method: 'ping'
    };
    await sendIPCRequest(daemonInfo.socket, request, 2000);
    return true;
  } catch {
    return false;
  }
}
export function generateRequestId(): string {
  return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
}
</file>

<file path="src/daemon/lock.ts">
import { lock } from 'proper-lockfile';
import fs from 'fs/promises';
import path from 'path';
import { existsSync } from 'fs';
import { createHash } from 'crypto';
export interface DaemonInfo {
  pid: number;
  socket: string;
  command: string;
  args: string[];
  started: string;
  lastAccess: string;
  cwd: string;
}
export interface DaemonLock {
  info: DaemonInfo;
  release: () => Promise<void>;
}
const MCPLI_DIR = '.mcpli';
const LEGACY_LOCK_FILE = 'daemon.lock';
const LEGACY_SOCK_FILE = 'daemon.sock';
function getMcpliDir(cwd = process.cwd()): string {
  return path.join(cwd, MCPLI_DIR);
}
/**
 * Returns the lock file path for a given daemon ID, or the legacy single-daemon path if no ID is provided.
 */
export function getLockFilePath(cwd: string, daemonId?: string): string {
  const dir = getMcpliDir(cwd);
  return daemonId ? path.join(dir, `daemon-${daemonId}.lock`) : path.join(dir, LEGACY_LOCK_FILE);
}
/**
 * Returns the socket path for a given daemon ID, or the legacy single-daemon path if no ID is provided.
 */
export function getSocketPath(cwd: string, daemonId?: string): string {
  const dir = getMcpliDir(cwd);
  return daemonId ? path.join(dir, `daemon-${daemonId}.sock`) : path.join(dir, LEGACY_SOCK_FILE);
}
async function ensureMcpliDir(cwd = process.cwd()): Promise<void> {
  const mcpliDir = getMcpliDir(cwd);
  if (!existsSync(mcpliDir)) {
    await fs.mkdir(mcpliDir, { recursive: true });
  }
}
/**
 * Normalize command and args across platforms (absolute path, normalized separators)
 */
export function normalizeCommand(command: string, args: string[] = []): { command: string; args: string[] } {
  const trimmed = String(command || '').trim();
  const normCommand = path.isAbsolute(trimmed)
    ? path.normalize(trimmed)
    : path.normalize(path.resolve(trimmed));
  const normArgs = (Array.isArray(args) ? args : [])
    .map((a) => String(a ?? '').trim())
    .filter((a) => a.length > 0);
  const normalizedCommand = process.platform === 'win32' ? normCommand.replace(/\\/g, '/').toLowerCase() : normCommand;
  const normalizedArgs = process.platform === 'win32'
    ? normArgs.map((a) => a.replace(/\\/g, '/'))
    : normArgs;
  return { command: normalizedCommand, args: normalizedArgs };
}
/**
 * Deterministic 8-char hash for identifying daemons by their command+args
 */
export function generateDaemonId(command: string, args: string[] = []): string {
  const norm = normalizeCommand(command, args);
  const input = JSON.stringify([norm.command, ...norm.args]);
  const digest = createHash('sha256').update(input).digest('hex');
  return digest.slice(0, 8);
}
/**
 * Acquire an exclusive lock for a daemon (per daemonId).
 * If daemonId is not provided, it is derived from command+args.
 */
export async function acquireDaemonLock(
  command: string,
  args: string[],
  cwd = process.cwd(),
  daemonId?: string
): Promise<DaemonLock> {
  await ensureMcpliDir(cwd);
  const id = daemonId ?? generateDaemonId(command, args);
  const lockPath = getLockFilePath(cwd, id);
  // Create empty lock file if it doesn't exist
  try {
    await fs.access(lockPath);
  } catch {
    await fs.writeFile(lockPath, '{}');
  }
  try {
    const releaseFileLock = await lock(lockPath, {
      retries: 0,
      stale: 60000 // 1 minute
    });
    const daemonInfo: DaemonInfo = {
      pid: process.pid,
      socket: getSocketPath(cwd, id),
      command,
      args,
      started: new Date().toISOString(),
      lastAccess: new Date().toISOString(),
      cwd
    };
    await fs.writeFile(lockPath, JSON.stringify(daemonInfo, null, 2));
    return {
      info: daemonInfo,
      release: async () => {
        try {
          await fs.unlink(lockPath);
        } catch {
          // File might already be deleted
        }
        await releaseFileLock();
      }
    };
  } catch (error) {
    throw new Error(`Cannot acquire daemon lock: ${error instanceof Error ? error.message : error}`);
  }
}
/**
 * Get daemon info for a specific daemonId. If daemonId is omitted,
 * falls back to legacy single-daemon file (daemon.lock).
 */
export async function getDaemonInfo(cwd = process.cwd(), daemonId?: string): Promise<DaemonInfo | null> {
  try {
    const lockPath = getLockFilePath(cwd, daemonId);
    const data = await fs.readFile(lockPath, 'utf8');
    return JSON.parse(data);
  } catch {
    return null;
  }
}
/**
 * Update lastAccess in daemon info. No-op if not found.
 */
export async function updateLastAccess(cwd = process.cwd(), daemonId?: string): Promise<void> {
  const info = await getDaemonInfo(cwd, daemonId);
  if (!info) return;
  info.lastAccess = new Date().toISOString();
  const lockPath = getLockFilePath(cwd, daemonId);
  try {
    await fs.writeFile(lockPath, JSON.stringify(info, null, 2));
  } catch {
    // Ignore write errors - daemon might be shutting down
  }
}
/**
 * Check if a daemon is running by reading its PID and sending signal 0.
 * If not running, cleans up stale lock file.
 */
export async function isDaemonRunning(cwd = process.cwd(), daemonId?: string): Promise<boolean> {
  const info = await getDaemonInfo(cwd, daemonId);
  if (!info || typeof info.pid !== 'number') return false;
  try {
    process.kill(info.pid, 0);
    return true;
  } catch {
    await cleanupStaleLock(cwd, daemonId);
    return false;
  }
}
/**
 * Remove a specific lock file (by daemonId) or legacy lock if no ID.
 */
export async function cleanupStaleLock(cwd = process.cwd(), daemonId?: string): Promise<void> {
  try {
    const lockPath = getLockFilePath(cwd, daemonId);
    await fs.unlink(lockPath);
  } catch {
    // Lock file might not exist or already cleaned up
  }
}
/**
 * Stop a specific daemon by ID (or legacy if none provided).
 */
export async function stopDaemon(cwd = process.cwd(), force = false, daemonId?: string): Promise<boolean> {
  const info = await getDaemonInfo(cwd, daemonId);
  if (!info) return false;
  try {
    process.kill(info.pid, force ? 'SIGKILL' : 'SIGTERM');
    if (!force) {
      // Wait up to 5 seconds for graceful shutdown
      for (let i = 0; i < 50; i++) {
        try {
          process.kill(info.pid, 0);
          await new Promise(resolve => setTimeout(resolve, 100));
        } catch {
          // Process has exited
          break;
        }
      }
      // Force kill if still running
      try {
        process.kill(info.pid, 0);
        process.kill(info.pid, 'SIGKILL');
      } catch {
        // Already exited
      }
    }
    await cleanupStaleLock(cwd, daemonId);
    return true;
  } catch {
    await cleanupStaleLock(cwd, daemonId);
    return false;
  }
}
/**
 * Enumerate all daemon IDs by scanning daemon-*.lock files.
 */
export async function listAllDaemons(cwd: string): Promise<string[]> {
  const mcpliDir = getMcpliDir(cwd);
  try {
    const entries = await fs.readdir(mcpliDir);
    const daemonIds = entries
      .filter(f => f.startsWith('daemon-') && f.endsWith('.lock'))
      .map(f => f.slice(7, -5));
    return Array.from(new Set(daemonIds));
  } catch {
    return [];
  }
}
/**
 * Remove stale per-daemon lock/socket files across all daemon IDs.
 */
export async function cleanupAllStaleDaemons(cwd: string): Promise<void> {
  const mcpliDir = getMcpliDir(cwd);
  try {
    const entries = await fs.readdir(mcpliDir);
    const lockFiles = entries.filter(f => f.startsWith('daemon-') && f.endsWith('.lock'));
    for (const lockFile of lockFiles) {
      const lockPath = path.join(mcpliDir, lockFile);
      const daemonId = lockFile.slice(7, -5);
      try {
        const info = JSON.parse(await fs.readFile(lockPath, 'utf8'));
        if (!info.pid || !isPidRunning(info.pid)) {
          await fs.unlink(lockPath).catch(() => {});
          const sockPath = path.join(mcpliDir, `daemon-${daemonId}.sock`);
          await fs.unlink(sockPath).catch(() => {});
        }
      } catch {
        await fs.unlink(lockPath).catch(() => {});
      }
    }
  } catch {
    // Directory doesn't exist or can't be read
  }
}
function isPidRunning(pid: number): boolean {
  try {
    process.kill(pid, 0);
    return true;
  } catch {
    return false;
  }
}
</file>

<file path="src/daemon/spawn.ts">
import { spawn, ChildProcess } from 'child_process';
import path from 'path';
import { fileURLToPath } from 'url';
import { DaemonLock, getDaemonInfo, getSocketPath, generateDaemonId } from './lock.js';
import { createIPCServer, IPCRequest } from './ipc.js';
import { Client } from '@modelcontextprotocol/sdk/client/index.js';
import { StdioClientTransport } from '@modelcontextprotocol/sdk/client/stdio.js';
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
export interface DaemonOptions {
  logs?: boolean;
  debug?: boolean;
  cwd?: string;
  timeout?: number;
  daemonId?: string;
}
export interface DaemonProcess {
  lock: DaemonLock;
  close: () => Promise<void>;
}
export async function startDaemon(
  command: string,
  args: string[],
  options: DaemonOptions = {}
): Promise<DaemonProcess> {
  const cwd = options.cwd || process.cwd();
  // Resolve daemon ID (prefer provided, otherwise derive from command+args)
  const id = options.daemonId ?? generateDaemonId(command, args);
  // Compute socket path for this daemonId
  const socketPath = getSocketPath(cwd, id);
  // Ensure .mcpli directory exists
  const fs = await import('fs/promises');
  const { existsSync } = await import('fs');
  const mcpliDir = path.join(cwd, '.mcpli');
  if (!existsSync(mcpliDir)) {
    await fs.mkdir(mcpliDir, { recursive: true });
  }
  // Wrapper script path
  const wrapperPath = path.join(__dirname, 'wrapper.js');
  // Spawn detached wrapper process
  const daemon = spawn('node', [wrapperPath], {
    detached: true,
    stdio: 'ignore',
    cwd,
    env: {
      ...process.env,
      MCPLI_SOCKET_PATH: socketPath,
      MCPLI_CWD: cwd,
      MCPLI_DEBUG: options.debug ? '1' : '0',
      MCPLI_TIMEOUT: (options.timeout || 30 * 60 * 1000).toString(),
      MCPLI_LOGS: options.logs ? '1' : '0',
      MCPLI_COMMAND: command,
      MCPLI_ARGS: JSON.stringify(args),
      MCPLI_DAEMON_ID: id
    }
  });
  daemon.unref();
  // Wait for IPC server ready
  await waitForDaemonReady(socketPath, 10000);
  // Read daemon info back from lock file
  const info = await getDaemonInfo(cwd, id);
  if (!info) {
    throw new Error('Failed to get daemon lock info after startup');
  }
  return {
    lock: {
      info,
      release: async () => {
        // Lock is owned by daemon; do nothing here
      }
    },
    close: async () => {
      try {
        if (daemon.pid) {
          process.kill(daemon.pid, 'SIGTERM');
          await new Promise(resolve => {
            const timeout = setTimeout(resolve, 5000);
            daemon.on('exit', () => {
              clearTimeout(timeout);
              resolve(undefined);
            });
          });
          try {
            if (daemon.pid) {
              process.kill(daemon.pid, 'SIGKILL');
            }
          } catch {
            // Already dead
          }
        }
      } catch {
        // Process may already be dead
      }
    }
  };
}
async function waitForDaemonReady(socketPath: string, timeoutMs: number): Promise<void> {
  const start = Date.now();
  while (Date.now() - start < timeoutMs) {
    try {
      const { sendIPCRequest, generateRequestId } = await import('./ipc.js');
      await sendIPCRequest(socketPath, {
        id: generateRequestId(),
        method: 'ping'
      }, 1000);
      return;
    } catch {
      await new Promise(resolve => setTimeout(resolve, 100));
    }
  }
  throw new Error(`Daemon failed to start within ${timeoutMs}ms`);
}
// In-process daemon for development/testing
export class InProcessDaemon {
  private mcpClient?: Client;
  private ipcServer?: any;
  public lock?: DaemonLock;
  private inactivityTimeout?: NodeJS.Timeout;
  constructor(
    private command: string,
    private args: string[],
    private options: DaemonOptions = {}
  ) {}
  async start(): Promise<void> {
    const cwd = this.options.cwd || process.cwd();
    const { acquireDaemonLock, generateDaemonId } = await import('./lock.js');
    const id = this.options.daemonId ?? generateDaemonId(this.command, this.args);
    // Acquire lock for this daemonId
    this.lock = await acquireDaemonLock(this.command, this.args, cwd, id);
    const transport = new StdioClientTransport({
      command: this.command,
      args: this.args,
      stderr: this.options.logs ? 'inherit' : 'ignore'
    });
    this.mcpClient = new Client({
      name: 'mcpli-daemon',
      version: '1.0.0'
    }, {
      capabilities: {}
    });
    await this.mcpClient.connect(transport);
    // Start IPC server for this daemonId's socket
    this.ipcServer = await createIPCServer(
      this.lock!.info.socket,
      this.handleIPCRequest.bind(this)
    );
    this.resetInactivityTimer();
    process.on('SIGTERM', this.gracefulShutdown.bind(this));
    process.on('SIGINT', this.gracefulShutdown.bind(this));
  }
  private async handleIPCRequest(request: IPCRequest): Promise<any> {
    this.resetInactivityTimer();
    switch (request.method) {
      case 'ping':
        return 'pong';
      case 'listTools':
        if (!this.mcpClient) throw new Error('MCP client not connected');
        return await this.mcpClient.listTools();
      case 'callTool':
        if (!this.mcpClient) throw new Error('MCP client not connected');
        return await this.mcpClient.callTool(request.params);
      default:
        throw new Error(`Unknown method: ${request.method}`);
    }
  }
  private resetInactivityTimer(): void {
    if (this.inactivityTimeout) {
      clearTimeout(this.inactivityTimeout);
    }
    const timeoutMs = this.options.timeout || 30 * 60 * 1000; // 30 minutes
    this.inactivityTimeout = setTimeout(() => {
      this.gracefulShutdown();
    }, timeoutMs);
  }
  private async gracefulShutdown(): Promise<void> {
    if (this.options.debug) {
      console.error('[DEBUG] Daemon shutting down gracefully');
    }
    if (this.inactivityTimeout) {
      clearTimeout(this.inactivityTimeout);
    }
    if (this.ipcServer) {
      await this.ipcServer.close();
    }
    if (this.mcpClient) {
      await this.mcpClient.close();
    }
    if (this.lock) {
      await this.lock.release();
    }
    process.exit(0);
  }
  async close(): Promise<void> {
    await this.gracefulShutdown();
  }
}
</file>

<file path="src/daemon/wrapper.js">
#!/usr/bin/env node
/**
 * MCPLI Daemon Wrapper - Long-lived MCP server process
 * 
 * This script runs as a detached daemon process and manages
 * a connection to an MCP server while providing IPC interface
 * for MCPLI commands.
 */
import { createIPCServer } from './ipc.js';
import { Client } from '@modelcontextprotocol/sdk/client/index.js';
import { StdioClientTransport } from '@modelcontextprotocol/sdk/client/stdio.js';
import { acquireDaemonLock } from './lock.js';
class MCPLIDaemon {
  constructor() {
    this.mcpClient = null;
    this.ipcServer = null;
    this.inactivityTimeout = null;
    this.isShuttingDown = false;
    this.daemonLock = null;
    // Read environment variables
    this.socketPath = process.env.MCPLI_SOCKET_PATH;
    this.cwd = process.env.MCPLI_CWD || process.cwd();
    this.debug = process.env.MCPLI_DEBUG === '1';
    this.logs = process.env.MCPLI_LOGS === '1';
    this.timeoutMs = parseInt(process.env.MCPLI_TIMEOUT || '1800000', 10); // 30 minutes
    this.mcpCommand = process.env.MCPLI_COMMAND;
    this.mcpArgs = JSON.parse(process.env.MCPLI_ARGS || '[]');
    this.daemonId = process.env.MCPLI_DAEMON_ID || undefined;
    if (!this.socketPath || !this.mcpCommand) {
      console.error('Missing required environment variables or arguments');
      process.exit(1);
    }
  }
  async start() {
    try {
      if (this.debug) {
        console.error(`[DAEMON] Starting with command: ${this.mcpCommand} ${this.mcpArgs.join(' ')}`);
        console.error(`[DAEMON] Socket path: ${this.socketPath}`);
        if (this.daemonId) {
          console.error(`[DAEMON] Daemon ID: ${this.daemonId}`);
        }
      }
      // Acquire daemon lock for this ID - writes correct PID and socket
      this.daemonLock = await acquireDaemonLock(this.mcpCommand, this.mcpArgs, this.cwd, this.daemonId);
      if (this.debug) {
        console.error(`[DAEMON] Lock acquired for PID ${this.daemonLock.info.pid}`);
      }
      // Start MCP client
      await this.startMCPClient();
      // Start IPC server
      await this.startIPCServer();
      // Set up cleanup handlers
      process.on('SIGTERM', this.gracefulShutdown.bind(this));
      process.on('SIGINT', this.gracefulShutdown.bind(this));
      process.on('uncaughtException', this.handleError.bind(this));
      process.on('unhandledRejection', this.handleError.bind(this));
      // Start inactivity timer
      this.resetInactivityTimer();
      if (this.debug) {
        console.error('[DAEMON] Started successfully');
      }
    } catch (error) {
      console.error('[DAEMON] Failed to start:', error);
      process.exit(1);
    }
  }
  async startMCPClient() {
    const transport = new StdioClientTransport({
      command: this.mcpCommand,
      args: this.mcpArgs,
      stderr: (this.debug || this.logs) ? 'inherit' : 'ignore'
    });
    this.mcpClient = new Client({
      name: 'mcpli-daemon',
      version: '1.0.0'
    }, {
      capabilities: {}
    });
    await this.mcpClient.connect(transport);
    if (this.debug) {
      console.error('[DAEMON] MCP client connected');
    }
  }
  async startIPCServer() {
    this.ipcServer = await createIPCServer(
      this.socketPath,
      this.handleIPCRequest.bind(this)
    );
    if (this.debug) {
      console.error('[DAEMON] IPC server listening on:', this.socketPath);
    }
  }
  async handleIPCRequest(request) {
    this.resetInactivityTimer();
    if (this.debug) {
      console.error(`[DAEMON] Handling IPC request: ${request.method}`);
    }
    switch (request.method) {
      case 'ping':
        return 'pong';
      case 'listTools':
        if (!this.mcpClient) throw new Error('MCP client not connected');
        return await this.mcpClient.listTools();
      case 'callTool':
        if (!this.mcpClient) throw new Error('MCP client not connected');
        return await this.mcpClient.callTool(request.params);
      default:
        throw new Error(`Unknown method: ${request.method}`);
    }
  }
  resetInactivityTimer() {
    if (this.inactivityTimeout) {
      clearTimeout(this.inactivityTimeout);
    }
    this.inactivityTimeout = setTimeout(() => {
      if (this.debug) {
        console.error('[DAEMON] Shutting down due to inactivity');
      }
      this.gracefulShutdown();
    }, this.timeoutMs);
  }
  async gracefulShutdown() {
    if (this.isShuttingDown) return;
    this.isShuttingDown = true;
    if (this.debug) {
      console.error('[DAEMON] Starting graceful shutdown');
    }
    if (this.inactivityTimeout) {
      clearTimeout(this.inactivityTimeout);
    }
    try {
      if (this.ipcServer) {
        await this.ipcServer.close();
        if (this.debug) {
          console.error('[DAEMON] IPC server closed');
        }
      }
      if (this.mcpClient) {
        await this.mcpClient.close();
        if (this.debug) {
          console.error('[DAEMON] MCP client closed');
        }
      }
    } catch (error) {
      console.error('[DAEMON] Error during shutdown:', error);
    }
    // Release the daemon lock
    if (this.daemonLock) {
      await this.daemonLock.release();
      if (this.debug) {
        console.error('[DAEMON] Lock released');
      }
    }
    if (this.debug) {
      console.error('[DAEMON] Shutdown complete');
    }
    process.exit(0);
  }
  handleError(error) {
    console.error('[DAEMON] Unhandled error:', error);
    this.gracefulShutdown();
  }
}
// Start the daemon
const daemon = new MCPLIDaemon();
daemon.start().catch(error => {
  console.error('[DAEMON] Fatal error:', error);
  process.exit(1);
});
</file>

<file path="src/mcpli-backup.ts">
#!/usr/bin/env node
/**
 * MCPLI - Turn any MCP server into a first-class CLI tool
 * 
 * This is a minimal working version to demonstrate the core concept.
 */
import { Client } from '@modelcontextprotocol/sdk/client/index.js';
import { StdioClientTransport } from '@modelcontextprotocol/sdk/client/stdio.js';
interface GlobalOptions {
  help?: boolean;
  quiet?: boolean;
  raw?: boolean;
  debug?: boolean;
  timeout?: number;
}
function parseArgs(argv: string[]) {
  const args = argv.slice(2); // Remove node and script name
  const globals: GlobalOptions = { timeout: 30000 };
  // Find the -- separator
  const dashIndex = args.indexOf('--');
  if (dashIndex === -1) {
    console.error('Error: Child command required after --');
    console.error('Usage: mcpli [options] [tool] [params...] -- <command> [args...]');
    process.exit(1);
  }
  const childCommand = args[dashIndex + 1];
  const childArgs = args.slice(dashIndex + 2);
  const userArgs = args.slice(0, dashIndex);
  if (!childCommand) {
    console.error('Error: Child command required after --');
    process.exit(1);
  }
  // Parse global options
  for (const arg of userArgs) {
    if (arg === '--help' || arg === '-h') globals.help = true;
    else if (arg === '--quiet' || arg === '-q') globals.quiet = true;
    else if (arg === '--raw') globals.raw = true;
    else if (arg === '--debug') globals.debug = true;
  }
  return { globals, childCommand, childArgs, userArgs };
}
async function discoverTools(command: string, args: string[], options: GlobalOptions) {
  const transport = new StdioClientTransport({
    command,
    args,
    stderr: options.quiet ? 'ignore' : 'inherit'
  });
  const client = new Client({
    name: 'mcpli',
    version: '1.0.0'
  }, {
    capabilities: {}
  });
  try {
    await client.connect(transport);
    const result = await client.listTools();
    return { tools: result.tools || [], client, close: () => client.close() };
  } catch (error) {
    throw new Error(`Failed to connect to MCP server: ${error instanceof Error ? error.message : error}`);
  }
}
function normalizeToolName(name: string): string {
  return name.toLowerCase().replace(/[^a-z0-9]/g, '');
}
function findTool(userArgs: string[], tools: any[]) {
  const toolMap = new Map();
  // Build tool index
  for (const tool of tools) {
    const name = tool.name;
    toolMap.set(name, tool);
    toolMap.set(name.replace(/_/g, '-'), tool);
    toolMap.set(normalizeToolName(name), tool);
  }
  // Look for tool selection
  for (const arg of userArgs) {
    if (arg.startsWith('--')) {
      const toolName = arg.slice(2);
      if (toolMap.has(toolName)) {
        return toolMap.get(toolName);
      }
    } else if (!arg.includes('=')) {
      if (toolMap.has(arg)) {
        return toolMap.get(arg);
      }
    }
  }
  return null;
}
function parseParams(userArgs: string[], selectedTool: any) {
  const params: Record<string, any> = {};
  const toolName = selectedTool?.name;
  for (const arg of userArgs) {
    // Skip tool selection
    if (arg === toolName || arg === `--${toolName}` || arg === `--${toolName.replace(/_/g, '-')}`) {
      continue;
    }
    if (arg.includes('=')) {
      const [key, value] = arg.split('=', 2);
      const cleanKey = key.replace(/^--/, '');
      // Try to parse as JSON, fall back to string
      try {
        if (value.startsWith('[') || value.startsWith('{') || value === 'true' || value === 'false' || !isNaN(Number(value))) {
          params[cleanKey] = JSON.parse(value);
        } else {
          params[cleanKey] = value;
        }
      } catch {
        params[cleanKey] = value;
      }
    }
  }
  return params;
}
function extractContent(result: any): any {
  if (!result.content || result.content.length === 0) {
    return null;
  }
  if (result.content.length === 1) {
    const item = result.content[0];
    if (item.type === 'text') {
      try {
        return JSON.parse(item.text);
      } catch {
        return item.text;
      }
    }
    return item;
  }
  return result.content.map((item: any) => {
    if (item.type === 'text') {
      try {
        return JSON.parse(item.text);
      } catch {
        return item.text;
      }
    }
    return item;
  });
}
function printHelp(tools: any[]) {
  console.log('MCPLI - Turn any MCP server into a first-class CLI tool');
  console.log('');
  console.log('Usage:');
  console.log('  mcpli [options] [--tool | tool] [params...] -- <command> [args...]');
  console.log('');
  console.log('Global Options:');
  console.log('  --help, -h     Show this help');
  console.log('  --quiet, -q    Suppress server stderr');
  console.log('  --raw          Print raw MCP response');
  console.log('  --debug        Enable debug output');
  console.log('');
  if (tools.length > 0) {
    console.log('Available Tools:');
    for (const tool of tools) {
      const name = tool.name.replace(/_/g, '-');
      const desc = tool.description || 'No description';
      console.log(`  --${name.padEnd(20)} ${desc.slice(0, 50)}${desc.length > 50 ? '...' : ''}`);
    }
    console.log('');
    console.log('Examples:');
    console.log(`  mcpli --${tools[0].name.replace(/_/g, '-')} -- node server.js`);
    console.log(`  mcpli ${tools[0].name} param="value" -- node server.js`);
  } else {
    console.log('Examples:');
    console.log('  mcpli --help -- node server.js');
  }
}
async function main() {
  try {
    const { globals, childCommand, childArgs, userArgs } = parseArgs(process.argv);
    if (globals.debug) {
      console.error('[DEBUG] Args:', { childCommand, childArgs, userArgs });
    }
    // Discover tools
    const { tools, client, close } = await discoverTools(childCommand, childArgs, globals);
    if (globals.debug) {
      console.error('[DEBUG] Found tools:', tools.map((t: any) => t.name));
    }
    // Show help if requested or no tool specified
    if (globals.help || userArgs.length === 0) {
      printHelp(tools);
      await close();
      return;
    }
    // Find selected tool
    const selectedTool = findTool(userArgs, tools);
    if (!selectedTool) {
      console.error('Error: No tool specified or tool not found');
      console.error('Use --help to see available tools');
      await close();
      process.exit(1);
    }
    if (globals.debug) {
      console.error('[DEBUG] Selected tool:', selectedTool.name);
    }
    // Parse parameters
    const params = parseParams(userArgs, selectedTool);
    if (globals.debug) {
      console.error('[DEBUG] Parameters:', params);
    }
    // Execute tool
    const result = await client.callTool({
      name: selectedTool.name,
      arguments: params
    });
    await close();
    // Output result
    if (globals.raw) {
      console.log(JSON.stringify(result, null, 2));
    } else {
      const extracted = extractContent(result);
      if (extracted !== null) {
        if (typeof extracted === 'string') {
          console.log(extracted);
        } else {
          console.log(JSON.stringify(extracted, null, 2));
        }
      }
    }
  } catch (error) {
    console.error(`Error: ${error instanceof Error ? error.message : error}`);
    process.exit(1);
  }
}
main();
</file>

<file path=".gitignore">
# Dependencies
node_modules/

# Build output
dist/

# Logs
*.log
logs/

# Runtime data
pids
*.pid
*.seed

# Coverage directory used by tools like istanbul
coverage/

# IDE files
.vscode/
.idea/

# OS generated files
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# Temporary files
*.tmp
*.temp

# Environment files
.env
.env.local
.env.development.local
.env.test.local
.env.production.local
</file>

<file path="LONG_LIVED_DESIGN.md">
# MCPLI Long-Lived Server Architecture

## Overview

Transform MCPLI from a stateless model (spawn server per command) to a stateful model where MCP servers run as long-lived background processes that persist across CLI invocations.

## Current Architecture vs. Target Architecture

### Current (Stateless)
```
mcpli --echo message="hello" -- node server.js
  
1. Spawn MCP server process
2. Connect via stdio
3. List tools, call tool
4. Close connection, kill process
```

### Target (Stateful)
```
mcpli daemon start -- node server.js     # Start long-lived server
mcpli --echo message="hello"             # Fast execution via IPC
mcpli daemon stop                        # Manual cleanup
```

## Design Principles

1. **Folder-based isolation**: One server instance per working directory
2. **Automatic discovery**: Commands work seamlessly whether server is running or not
3. **Graceful fallback**: If daemon fails, fall back to stateless mode
4. **Resource management**: Automatic cleanup after inactivity
5. **Simple UX**: Users shouldn't need to think about process management

## File Structure

```
.mcpli/
 daemon.lock          # Combined lock/PID file
 daemon.sock          # Unix domain socket for IPC
 daemon.log           # Server logs (if --logs enabled)
 daemon.config.json   # Server configuration cache
```

## Core Components

### 1. Lock/PID File Management

**File**: `.mcpli/daemon.lock`
```json
{
  "pid": 12345,
  "socket": ".mcpli/daemon.sock",
  "command": "node server.js",
  "args": [],
  "started": "2024-01-15T10:30:00Z",
  "lastAccess": "2024-01-15T11:45:00Z"
}
```

**Implementation**:
- Use `proper-lockfile` for atomic lock acquisition
- Store both PID and IPC connection details
- Update `lastAccess` on every command
- Clean up on graceful shutdown

### 2. Process Lifecycle Management

#### Starting a Daemon
```bash
# Explicit start
mcpli daemon start -- node server.js

# Auto-start (if no daemon running)
mcpli --echo message="test"  # Starts daemon transparently
```

**Flow**:
1. Check if `.mcpli/daemon.lock` exists and is valid
2. If not, acquire exclusive lock on the file
3. Spawn detached MCP server process
4. Write daemon info to lock file
5. Set up Unix domain socket for IPC
6. Cache discovered tools in `daemon.config.json`

#### Daemon Process Setup
```javascript
// daemon-manager.js
async function startDaemon(command, args, options) {
  const lockPath = path.join(process.cwd(), '.mcpli', 'daemon.lock');
  const release = await lock(lockPath, { retries: 0 });
  
  const daemon = spawn(command, args, {
    detached: true,
    stdio: ['ignore', 'ignore', options.logs ? 'inherit' : 'ignore']
  });
  
  const daemonInfo = {
    pid: daemon.pid,
    socket: '.mcpli/daemon.sock',
    command,
    args,
    started: new Date().toISOString(),
    lastAccess: new Date().toISOString()
  };
  
  await fs.writeFile(lockPath, JSON.stringify(daemonInfo));
  daemon.unref();
  
  // Set up cleanup handlers
  process.on('SIGTERM', async () => {
    await release();
    await fs.unlink(lockPath);
  });
}
```

### 3. Inter-Process Communication

**Transport**: Unix Domain Sockets (cross-platform via Node.js `net` module)
**Protocol**: JSON-RPC over socket

#### Server Side (in spawned MCP server wrapper)
```javascript
// daemon-wrapper.js - wraps the actual MCP server
import net from 'net';
import { Client } from '@modelcontextprotocol/sdk/client/index.js';

const server = net.createServer((client) => {
  client.on('data', async (data) => {
    try {
      const request = JSON.parse(data.toString());
      const response = await handleRequest(request);
      client.write(JSON.stringify(response));
    } catch (error) {
      client.write(JSON.stringify({ error: error.message }));
    }
  });
});

async function handleRequest(request) {
  switch (request.method) {
    case 'listTools':
      return await mcpClient.listTools();
    case 'callTool':
      return await mcpClient.callTool(request.params);
    default:
      throw new Error(`Unknown method: ${request.method}`);
  }
}
```

#### Client Side (MCPLI)
```javascript
// daemon-client.js
async function callDaemon(method, params) {
  const sockPath = path.join(process.cwd(), '.mcpli', 'daemon.sock');
  
  return new Promise((resolve, reject) => {
    const client = net.connect(sockPath, () => {
      const request = { method, params, id: Date.now() };
      client.write(JSON.stringify(request));
    });
    
    client.on('data', (data) => {
      const response = JSON.parse(data.toString());
      client.end();
      resolve(response);
    });
    
    client.on('error', reject);
  });
}
```

### 4. Command Execution Flow

#### Fast Path (Daemon Running)
```javascript
async function executeCommand(selectedTool, params, options) {
  try {
    // Try daemon first
    if (await isDaemonRunning()) {
      await updateLastAccess();
      const result = await callDaemon('callTool', { name: selectedTool.name, arguments: params });
      return result;
    }
  } catch (error) {
    if (options.debug) {
      console.error('[DEBUG] Daemon failed, falling back to direct mode:', error.message);
    }
  }
  
  // Fallback to stateless mode
  return executeStateless(selectedTool, params, options);
}
```

#### Automatic Daemon Startup
```javascript
async function ensureDaemonRunning(childCommand, childArgs, options) {
  if (!(await isDaemonRunning())) {
    if (options.debug) {
      console.error('[DEBUG] Starting daemon automatically');
    }
    await startDaemon(childCommand, childArgs, options);
    
    // Wait for daemon to be ready
    await waitForDaemon(5000); // 5 second timeout
  }
}
```

### 5. Resource Management

#### Inactivity Timeout
```javascript
// In daemon-wrapper.js
let inactivityTimeout;
const TIMEOUT_MS = 30 * 60 * 1000; // 30 minutes

function resetInactivityTimer() {
  clearTimeout(inactivityTimeout);
  inactivityTimeout = setTimeout(gracefulShutdown, TIMEOUT_MS);
}

function gracefulShutdown() {
  console.log('Daemon shutting down due to inactivity');
  server.close();
  fs.unlink('.mcpli/daemon.lock');
  process.exit(0);
}

// Reset timer on each request
server.on('connection', resetInactivityTimer);
```

#### Manual Cleanup Commands
```bash
mcpli daemon stop     # Graceful shutdown
mcpli daemon restart  # Stop and start
mcpli daemon status   # Show daemon info
mcpli daemon logs     # Show daemon logs
```

### 6. Error Handling & Fallbacks

#### Daemon Health Checks
```javascript
async function isDaemonRunning() {
  try {
    const lockPath = path.join(process.cwd(), '.mcpli', 'daemon.lock');
    const lockData = JSON.parse(await fs.readFile(lockPath, 'utf8'));
    
    // Check if PID is still running
    try {
      process.kill(lockData.pid, 0); // Test signal
      return true;
    } catch {
      // Process not running, clean up stale lock
      await fs.unlink(lockPath);
      return false;
    }
  } catch {
    return false;
  }
}
```

#### Graceful Degradation
1. **Daemon unavailable**: Fall back to stateless mode
2. **Socket connection fails**: Retry once, then fall back
3. **Stale lock files**: Clean up and start fresh daemon
4. **Corrupted state**: Reset to clean state

## Implementation Plan

### Phase 1: Core Infrastructure
1. **Lock file management** (`src/daemon/lock.ts`)
2. **Process spawning** (`src/daemon/spawn.ts`)
3. **IPC setup** (`src/daemon/ipc.ts`)
4. **Health checks** (`src/daemon/health.ts`)

### Phase 2: Command Integration
1. **Modify main CLI** to check for daemon first
2. **Add daemon subcommands** (`start`, `stop`, `status`, `restart`)
3. **Implement fallback logic**
4. **Add auto-start capability**

### Phase 3: Polish & Testing
1. **Comprehensive error handling**
2. **Cross-platform testing** (Windows, macOS, Linux)
3. **Performance benchmarking** (startup time improvements)
4. **Documentation and examples**

## Expected Benefits

1. **Performance**: ~100-1000x faster command execution (no spawn overhead)
2. **State preservation**: Tools can maintain caches, connections, etc.
3. **Better resource usage**: One server process vs many short-lived processes
4. **Enhanced capabilities**: Enables features like file watching, real-time updates

## Migration Strategy

1. **Backward compatibility**: All existing commands work unchanged
2. **Opt-in initially**: Users can explicitly start daemons
3. **Gradual rollout**: Auto-start behind feature flag
4. **Fallback guaranteed**: Stateless mode always available

## Security Considerations

1. **Socket permissions**: Restrict `.mcpli/daemon.sock` to owner only
2. **PID verification**: Ensure we're signaling the correct process
3. **Directory isolation**: Each project gets its own daemon instance
4. **Cleanup on exit**: Remove sockets and lock files on shutdown

This architecture transforms MCPLI from a simple wrapper to a sophisticated process management system while maintaining the simple CLI interface users expect.
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ESNext",
    "moduleResolution": "Node",
    "lib": ["ES2022"],
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "allowSyntheticDefaultImports": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}
</file>

<file path="weather-server.js">
#!/usr/bin/env node
/**
 * Weather MCP Server
 * 
 * A simple MCP server that provides weather information using the free
 * Open-Meteo API (no API key required).
 * 
 * Supports:
 * - City name lookup (geocoded to coordinates)
 * - Direct latitude/longitude coordinates
 * - Current weather and forecasts
 */
import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import { 
  ListToolsRequestSchema, 
  CallToolRequestSchema
} from '@modelcontextprotocol/sdk/types.js';
// Free geocoding service to convert city names to coordinates
async function geocodeCity(cityName) {
  try {
    const response = await fetch(
      `https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(cityName)}&count=1&language=en&format=json`
    );
    const data = await response.json();
    if (!data.results || data.results.length === 0) {
      throw new Error(`City "${cityName}" not found`);
    }
    const result = data.results[0];
    return {
      latitude: result.latitude,
      longitude: result.longitude,
      name: result.name,
      country: result.country,
      admin1: result.admin1 // State/region
    };
  } catch (error) {
    throw new Error(`Geocoding failed: ${error.message}`);
  }
}
// Get weather data from Open-Meteo API
async function getWeatherData(latitude, longitude, options = {}) {
  try {
    const params = new URLSearchParams({
      latitude: latitude.toString(),
      longitude: longitude.toString(),
      current: 'temperature_2m,relative_humidity_2m,apparent_temperature,precipitation,weather_code,wind_speed_10m,wind_direction_10m',
      timezone: 'auto',
      temperature_unit: options.units === 'fahrenheit' ? 'fahrenheit' : 'celsius',
      wind_speed_unit: 'mph',
      precipitation_unit: 'inch'
    });
    if (options.forecast_days) {
      params.append('daily', 'temperature_2m_max,temperature_2m_min,weather_code,precipitation_sum');
      params.append('forecast_days', options.forecast_days.toString());
    }
    const response = await fetch(`https://api.open-meteo.com/v1/forecast?${params}`);
    const data = await response.json();
    if (data.error) {
      throw new Error(`Weather API error: ${data.reason}`);
    }
    return data;
  } catch (error) {
    throw new Error(`Weather API failed: ${error.message}`);
  }
}
// Convert weather codes to human-readable descriptions
function getWeatherDescription(code) {
  const descriptions = {
    0: 'Clear sky',
    1: 'Mainly clear',
    2: 'Partly cloudy',
    3: 'Overcast',
    45: 'Fog',
    48: 'Depositing rime fog',
    51: 'Light drizzle',
    53: 'Moderate drizzle',
    55: 'Dense drizzle',
    61: 'Slight rain',
    63: 'Moderate rain',
    65: 'Heavy rain',
    71: 'Slight snow',
    73: 'Moderate snow',
    75: 'Heavy snow',
    80: 'Slight rain showers',
    81: 'Moderate rain showers',
    82: 'Violent rain showers',
    95: 'Thunderstorm',
    96: 'Thunderstorm with hail',
    99: 'Thunderstorm with heavy hail'
  };
  return descriptions[code] || `Unknown weather (code: ${code})`;
}
// Create and configure the MCP server
const server = new Server(
  {
    name: 'weather-server',
    version: '1.0.0'
  },
  {
    capabilities: {
      tools: {}
    }
  }
);
// Register the get-weather tool
server.setRequestHandler(ListToolsRequestSchema, async () => {
  return {
    tools: [
      {
        name: 'get_weather',
        description: 'Get current weather information for any location',
        inputSchema: {
          type: 'object',
          properties: {
            location: {
              type: 'string',
              description: 'City name (e.g., "New York", "London, UK") or coordinates as "lat,lon"'
            },
            units: {
              type: 'string',
              description: 'Temperature units',
              enum: ['celsius', 'fahrenheit'],
              default: 'fahrenheit'
            }
          },
          required: ['location']
        }
      },
      {
        name: 'get_forecast',
        description: 'Get weather forecast for multiple days',
        inputSchema: {
          type: 'object',
          properties: {
            location: {
              type: 'string',
              description: 'City name (e.g., "New York", "London, UK") or coordinates as "lat,lon"'
            },
            days: {
              type: 'integer',
              description: 'Number of forecast days (1-16)',
              minimum: 1,
              maximum: 16,
              default: 5
            },
            units: {
              type: 'string',
              description: 'Temperature units',
              enum: ['celsius', 'fahrenheit'],
              default: 'fahrenheit'
            }
          },
          required: ['location']
        }
      }
    ]
  };
});
// Handle tool calls
server.setRequestHandler(CallToolRequestSchema, async (request) => {
  const { name, arguments: args } = request.params;
  try {
    if (name === 'get_weather') {
      const { location, units = 'fahrenheit' } = args;
      let latitude, longitude, locationName;
      // Check if location is coordinates (lat,lon format)
      if (location.includes(',')) {
        const [lat, lon] = location.split(',').map(s => parseFloat(s.trim()));
        if (isNaN(lat) || isNaN(lon)) {
          throw new Error('Invalid coordinates format. Use "latitude,longitude" (e.g., "40.7128,-74.0060")');
        }
        latitude = lat;
        longitude = lon;
        locationName = `${latitude}, ${longitude}`;
      } else {
        // Geocode city name
        const geocoded = await geocodeCity(location);
        latitude = geocoded.latitude;
        longitude = geocoded.longitude;
        locationName = `${geocoded.name}, ${geocoded.admin1 ? geocoded.admin1 + ', ' : ''}${geocoded.country}`;
      }
      // Get weather data
      const weatherData = await getWeatherData(latitude, longitude, { units });
      const current = weatherData.current;
      const result = {
        location: locationName,
        coordinates: { latitude, longitude },
        temperature: `${Math.round(current.temperature_2m)}${units === 'celsius' ? 'C' : 'F'}`,
        feels_like: `${Math.round(current.apparent_temperature)}${units === 'celsius' ? 'C' : 'F'}`,
        humidity: `${current.relative_humidity_2m}%`,
        wind: `${Math.round(current.wind_speed_10m)} mph ${getWindDirection(current.wind_direction_10m)}`,
        condition: getWeatherDescription(current.weather_code),
        precipitation: `${current.precipitation}" rain`,
        timestamp: current.time
      };
      return {
        content: [
          {
            type: 'text',
            text: JSON.stringify(result, null, 2)
          }
        ]
      };
    } else if (name === 'get_forecast') {
      const { location, days = 5, units = 'fahrenheit' } = args;
      let latitude, longitude, locationName;
      // Check if location is coordinates
      if (location.includes(',')) {
        const [lat, lon] = location.split(',').map(s => parseFloat(s.trim()));
        if (isNaN(lat) || isNaN(lon)) {
          throw new Error('Invalid coordinates format. Use "latitude,longitude"');
        }
        latitude = lat;
        longitude = lon;
        locationName = `${latitude}, ${longitude}`;
      } else {
        // Geocode city name
        const geocoded = await geocodeCity(location);
        latitude = geocoded.latitude;
        longitude = geocoded.longitude;
        locationName = `${geocoded.name}, ${geocoded.admin1 ? geocoded.admin1 + ', ' : ''}${geocoded.country}`;
      }
      // Get forecast data
      const weatherData = await getWeatherData(latitude, longitude, { 
        units, 
        forecast_days: Math.min(Math.max(days, 1), 16) 
      });
      const daily = weatherData.daily;
      const forecast = daily.time.map((date, index) => ({
        date,
        high: `${Math.round(daily.temperature_2m_max[index])}${units === 'celsius' ? 'C' : 'F'}`,
        low: `${Math.round(daily.temperature_2m_min[index])}${units === 'celsius' ? 'C' : 'F'}`,
        condition: getWeatherDescription(daily.weather_code[index]),
        precipitation: `${daily.precipitation_sum[index]}" rain`
      }));
      const result = {
        location: locationName,
        coordinates: { latitude, longitude },
        forecast
      };
      return {
        content: [
          {
            type: 'text',
            text: JSON.stringify(result, null, 2)
          }
        ]
      };
    } else {
      throw new Error(`Unknown tool: ${name}`);
    }
  } catch (error) {
    return {
      content: [
        {
          type: 'text',
          text: JSON.stringify({
            error: error.message,
            tool: name,
            arguments: args
          }, null, 2)
        }
      ],
      isError: true
    };
  }
});
// Helper function to convert wind direction degrees to cardinal direction
function getWindDirection(degrees) {
  const directions = ['N', 'NNE', 'NE', 'ENE', 'E', 'ESE', 'SE', 'SSE', 'S', 'SSW', 'SW', 'WSW', 'W', 'WNW', 'NW', 'NNW'];
  const index = Math.round(degrees / 22.5) % 16;
  return directions[index];
}
// Start the server
async function main() {
  const transport = new StdioServerTransport();
  await server.connect(transport);
  console.error('Weather MCP Server running...');
}
main().catch(error => {
  console.error('Server error:', error);
  process.exit(1);
});
</file>

<file path="package.json">
{
  "name": "mcpli",
  "version": "1.0.0",
  "type": "module",
  "description": "Turn any MCP server into a first-class CLI tool",
  "bin": {
    "mcpli": "dist/mcpli.js"
  },
  "scripts": {
    "build": "tsc && cp src/daemon/wrapper.js dist/daemon/wrapper.js",
    "postbuild": "chmod +x dist/mcpli.js"
  },
  "dependencies": {
    "@modelcontextprotocol/sdk": "^1.12.3",
    "proper-lockfile": "^4.1.2"
  },
  "devDependencies": {
    "@types/node": "^22.10.2",
    "@types/proper-lockfile": "^4.1.4",
    "typescript": "^5.7.2"
  },
  "engines": {
    "node": ">=18.0.0"
  }
}
</file>

<file path="README.md">
# MCPLI

**Transform any MCP server into a first-class CLI tool.**

MCPLI automatically discovers tools from MCP servers and generates natural command-line interfaces. Point it at any server and get instant CLI access to all its tools.

## Quick Start

```bash
# Install globally via npm
npm install -g mcpli

# Start with included weather server
node mcpli.js daemon start -- node weather-server.js
node mcpli.js get-weather --location "San Francisco"
```

## Features

-  **Zero Configuration** - Point at any MCP server, get instant CLI
-  **Natural Syntax** - Tools become commands: `mcpli get-weather --location "NYC"`
-  **Auto-Generated Help** - `mcpli --help` shows all tools, `mcpli tool-name --help` shows parameters
-  **Fast Daemon Mode** - Keep servers running for instant repeated calls
-  **Clean Output** - Structured JSON perfect for shell pipelines
-  **Flexible Parameters** - Supports `--key value` and `--key=value` formats

## Installation

### Global Installation
```bash
npm install -g mcpli
```

### Direct Usage (No Installation)
```bash
npx mcpli <command>
```

## Usage

MCPLI has two modes: **stateless mode** (specify server each time) and **daemon mode** (fast persistent server).

### Stateless Mode
```bash
# Basic syntax - specify server command each time
mcpli <tool> [tool-options...] -- <mcp-server> [args...]

# Discover available tools
mcpli --help -- node weather-server.js

# Get tool-specific help  
mcpli get-weather --help -- node weather-server.js

# Execute tools
mcpli get-weather --location "San Francisco" -- node weather-server.js
```

### Daemon Mode (Recommended)
```bash  
# Start daemon for a server (auto-starts on first use)
mcpli daemon start -- node weather-server.js

# Now use tools without specifying server - much faster!
mcpli get-weather --location "San Francisco"
mcpli get-forecast --location "NYC" --days 5

# Show help from running daemon
mcpli --help
mcpli get-weather --help

# Manage daemon
mcpli daemon status    # Show daemon info
mcpli daemon stop      # Stop daemon
mcpli daemon restart -- node weather-server.js
```

## Examples

All examples below use the included servers in this project that you can run immediately.

### Weather Server (included: `weather-server.js`)
```bash
# Start daemon
mcpli daemon start -- node weather-server.js

# Get current weather by city
mcpli get-weather --location "London"

# Get weather by coordinates  
mcpli get-weather --location "40.7128,-74.0060"

# Get 5-day forecast
mcpli get-forecast --location "Tokyo" --days 5 --units celsius
```

### Complex Data Types Test (included: `complex-test-server.js`)
```bash
# Start daemon with test server
mcpli daemon start -- node complex-test-server.js

# Test all JSON Schema data types
mcpli test-all-types \
  --text "hello world" \
  --count 42 \
  --rating -123.456 \
  --enabled true \
  --empty null \
  --tags='["tag1","tag2","tag3"]' \
  --config='{"timeout":5000,"retries":3,"debug":true}'
```

## Advanced Features

### High-Performance Daemon Mode

MCPLI runs MCP servers as long-lived background processes for dramatically improved performance:

```bash
# Start daemon (auto-starts on first tool use)
mcpli daemon start -- node weather-server.js

# All subsequent commands use the fast daemon automatically
mcpli get-weather --location "NYC"  # ~1000x faster than spawning

# Daemon management
mcpli daemon status    # Show PID, uptime, last access
mcpli daemon stop      # Stop daemon
mcpli daemon clean     # Clean up all daemon files
```

### Data Types

MCPLI handles any data type your MCP server uses:

```bash
# Simple values
mcpli get-weather --location "NYC" --enabled

# Numbers and arrays  
mcpli test-all-types --count 42 --rating -123.456 --tags='["web","api"]'

# Complex objects
mcpli test-all-types --config='{"timeout":5000,"debug":true}'
```

### Composable Output

Clean JSON output perfect for shell automation:

```bash
# Extract specific data with jq
mcpli get-weather --location "NYC" | jq -r '.temperature'

# Process multiple locations
for city in "NYC" "London" "Tokyo"; do
  mcpli get-weather --location "$city" | jq -r '.location + ": " + .temperature'
done

# Chain with other tools
mcpli get-forecast --location "NYC" --days 3 | jq '.forecast[].date'
```

### Debug and Development

```bash
# Show raw MCP responses
mcpli get-weather --location "NYC" --raw

# Enable debug output
mcpli get-weather --location "NYC" --debug

# Show daemon activity
mcpli daemon status
```

## Included Test Servers

This project includes working MCP servers you can use immediately:

### Weather Server (`weather-server.js`)
```bash
# Start daemon and get weather data
mcpli daemon start -- node weather-server.js
mcpli get-weather --location "London"
mcpli get-weather --location "40.7128,-74.0060"  # NYC coordinates
mcpli get-forecast --location "Tokyo" --days 5 --units celsius
```

### Complex Data Types Test Server (`complex-test-server.js`)  
```bash
# Start daemon and test comprehensive JSON Schema support
mcpli daemon start -- node complex-test-server.js

# Test primitive types
mcpli test-all-types --text "hello" --count 42 --rating -123.456 --enabled true --empty null

# Test arrays and objects
mcpli test-all-types \
  --text "complex test" \
  --count 1 \
  --tags='["web","mobile","api"]' \
  --scores='[98.5, -0.1, 1.23e-4]' \
  --config='{"timeout":5000,"retries":3,"debug":true}' \
  --metadata='{"user":{"id":123,"name":"Alice","preferences":["dark","en"]},"timestamps":[1629384000,1629470400]}'
```

## Parameter Syntax

| Type | Example |
|------|---------|
| Strings | `--location "San Francisco"` |
| Numbers | `--count 42` or `--rating -123.456` |
| Booleans | `--enabled` or `--debug false` |
| Arrays | `--tags='["web","api"]'` |
| Objects | `--config='{"timeout":5000}'` |

Both `--key value` and `--key=value` work for all types.

## FAQ

**Q: Do I need to configure anything?**
A: No! Point MCPLI at any MCP server and it automatically discovers and exposes all tools.

**Q: What's the difference between stateless and daemon mode?**
A: Stateless spawns the server for each command. Daemon keeps it running for 100-1000x faster execution.

**Q: How do I pass JSON objects or arrays?**
A: Use single quotes: `--config='{"key":"value"}'` or `--items='[1,2,3]'`

**Q: Can I use this in shell scripts?**
A: Yes! Clean JSON output works great with `jq` and shell pipelines.

## Requirements

- Node.js 18+
- Any MCP-compliant server

## Getting Started

1. **Clone and build** (or install from npm when published):
   ```bash
   git clone <this-repo>
   cd mcpli
   npm install
   npm run build
   ```

2. **Try the included weather server**:
   ```bash
   node dist/mcpli.js daemon start -- node weather-server.js
   node dist/mcpli.js get-weather --location "San Francisco"
   ```

3. **Test comprehensive data types**:
   ```bash
   node dist/mcpli.js daemon stop
   node dist/mcpli.js daemon start -- node complex-test-server.js
   node dist/mcpli.js test-all-types --text "test" --count 42 --rating -123.45
   ```

## Architecture

- **Daemon Architecture**: Long-lived background processes with Unix domain socket IPC
- **JSON Schema Parser**: Full MCP protocol compliance with schema-driven type conversion  
- **Perfect CLI Ergonomics**: Tools become first-class commands with natural parameter syntax
- **Process Management**: Atomic file locking, graceful shutdown, automatic cleanup

## License

MIT

---

**Transform any MCP server into a perfect CLI tool. Zero configuration required.**
</file>

<file path="test-server.js">
#!/usr/bin/env node
/**
 * Simple test MCP server for testing MCPLI
 */
import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import { ListToolsRequestSchema, CallToolRequestSchema } from '@modelcontextprotocol/sdk/types.js';
const server = new Server(
  {
    name: 'test-server',
    version: '1.0.0'
  },
  {
    capabilities: {
      tools: {}
    }
  }
);
// Add tools list handler
server.setRequestHandler(ListToolsRequestSchema, async () => ({
  tools: [
    {
      name: 'echo',
      description: 'Echo back the provided message',
      inputSchema: {
        type: 'object',
        properties: {
          message: {
            type: 'string',
            description: 'The message to echo back'
          }
        },
        required: ['message']
      }
    },
    {
      name: 'get_weather',
      description: 'Get weather information for a location',
      inputSchema: {
        type: 'object',
        properties: {
          location: {
            type: 'string',
            description: 'The location to get weather for'
          },
          units: {
            type: 'string',
            description: 'Temperature units (celsius or fahrenheit)',
            default: 'fahrenheit'
          }
        },
        required: ['location']
      }
    },
    {
      name: 'list_items',
      description: 'List items with optional filtering',
      inputSchema: {
        type: 'object',
        properties: {
          category: {
            type: 'string',
            description: 'Filter by category'
          },
          limit: {
            type: 'integer',
            description: 'Maximum number of items to return'
          },
          active_only: {
            type: 'boolean',
            description: 'Only return active items',
            default: false
          }
        }
      }
    }
  ]
}));
// Add tool call handler
server.setRequestHandler(CallToolRequestSchema, async (request) => {
  const { name, arguments: args } = request.params;
  switch (name) {
    case 'echo':
      return {
        content: [
          {
            type: 'text',
            text: args?.message || 'No message provided'
          }
        ]
      };
    case 'get_weather':
      const location = args?.location || 'Unknown';
      const units = args?.units || 'fahrenheit';
      const temp = units === 'celsius' ? '22C' : '72F';
      return {
        content: [
          {
            type: 'text',
            text: JSON.stringify({
              location,
              temperature: temp,
              condition: 'Sunny',
              humidity: '65%'
            })
          }
        ]
      };
    case 'list_items':
      const category = args?.category || 'all';
      const limit = args?.limit || 10;
      const activeOnly = args?.active_only || false;
      const items = [
        { id: 1, name: 'Item 1', category: 'electronics', active: true },
        { id: 2, name: 'Item 2', category: 'books', active: false },
        { id: 3, name: 'Item 3', category: 'electronics', active: true },
        { id: 4, name: 'Item 4', category: 'clothing', active: true },
        { id: 5, name: 'Item 5', category: 'books', active: true }
      ].filter(item => {
        if (category !== 'all' && item.category !== category) return false;
        if (activeOnly && !item.active) return false;
        return true;
      }).slice(0, limit);
      return {
        content: [
          {
            type: 'text',
            text: JSON.stringify(items)
          }
        ]
      };
    default:
      throw new Error(`Unknown tool: ${name}`);
  }
});
// Start the server
const transport = new StdioServerTransport();
server.connect(transport).catch((error) => {
  console.error('Server failed to start:', error);
  process.exit(1);
});
</file>

<file path="src/mcpli.ts">
#!/usr/bin/env node
/**
 * MCPLI - Turn any MCP server into a first-class CLI tool
 * 
 * This version supports both stateless mode and long-lived daemon processes.
 */
import { Client } from '@modelcontextprotocol/sdk/client/index.js';
import { StdioClientTransport } from '@modelcontextprotocol/sdk/client/stdio.js';
import { DaemonClient } from './daemon/index.js';
import { 
  handleDaemonStart, 
  handleDaemonStop, 
  handleDaemonStatus, 
  handleDaemonRestart,
  handleDaemonLogs,
  handleDaemonClean,
  printDaemonHelp
} from './daemon/index.js';
interface GlobalOptions {
  help?: boolean;
  quiet?: boolean;
  raw?: boolean;
  debug?: boolean;
  logs?: boolean;
  verbose?: boolean;
  timeout?: number;
  daemon?: boolean;
  force?: boolean;
}
function parseArgs(argv: string[]) {
  const args = argv.slice(2); // Remove node and script name
  const globals: GlobalOptions = { timeout: 30000 };
  // Check for daemon subcommand
  if (args[0] === 'daemon') {
    globals.daemon = true;
    // Check if help is requested for daemon
    if (args[1] === '--help' || args[1] === '-h') {
      globals.help = true;
      return { 
        globals, 
        daemonCommand: '',
        daemonArgs: [],
        childCommand: '',
        childArgs: [],
        userArgs: []
      };
    }
    const daemonCommand = args[1];
    const daemonArgs = args.slice(2);
    // Parse daemon-specific options
    for (const arg of daemonArgs) {
      if (arg === '--help' || arg === '-h') globals.help = true;
      else if (arg === '--debug') globals.debug = true;
      else if (arg === '--logs') globals.logs = true;
      else if (arg === '--verbose') globals.verbose = true;
      else if (arg === '--force') globals.force = true;
      else if (arg.startsWith('--timeout=')) {
        globals.timeout = parseInt(arg.split('=')[1], 10);
      }
    }
    return { 
      globals, 
      daemonCommand, 
      daemonArgs,
      childCommand: '',
      childArgs: [],
      userArgs: []
    };
  }
  // Regular tool execution mode - find the -- separator
  const dashIndex = args.indexOf('--');
  if (dashIndex === -1) {
    // For help or when no command specified, allow missing --
    if (args.includes('--help') || args.includes('-h') || args.length === 0) {
      return {
        globals: { ...globals, help: true },
        childCommand: '',
        childArgs: [],
        userArgs: args
      };
    }
    // Check if there might be a daemon running - allow daemon mode
    // In daemon mode, no -- is required as the server is already running
    return {
      globals,
      childCommand: '', // Empty means try daemon mode
      childArgs: [],
      userArgs: args
    };
  }
  const childCommand = args[dashIndex + 1];
  const childArgs = args.slice(dashIndex + 2);
  const userArgs = args.slice(0, dashIndex);
  if (!childCommand) {
    console.error('Error: Child command required after --');
    process.exit(1);
  }
  // Parse global options - but don't set help=true if there's a tool name before --help
  let foundToolName = false;
  for (const arg of userArgs) {
    if (!arg.startsWith('--') && !arg.startsWith('-') && !foundToolName) {
      foundToolName = true; // This might be a tool name
      continue;
    }
    if (arg === '--help' || arg === '-h') {
      // Only set global help if no tool name was found
      if (!foundToolName) {
        globals.help = true;
      }
    }
    else if (arg === '--quiet' || arg === '-q') globals.quiet = true;
    else if (arg === '--raw') globals.raw = true;
    else if (arg === '--debug') globals.debug = true;
    else if (arg === '--logs') globals.logs = true;
    else if (arg === '--verbose') globals.verbose = true;
    else if (arg.startsWith('--timeout=')) {
      globals.timeout = parseInt(arg.split('=')[1], 10);
    }
  }
  return { globals, childCommand, childArgs, userArgs };
}
async function discoverTools(command: string, args: string[], options: GlobalOptions) {
  // If no command provided, only try daemon mode (no fallback to stateless)
  const daemonOnly = !command;
  // Try daemon client first, with fallback to direct connection
  const daemonClient = new DaemonClient(command, args, {
    logs: options.logs || options.verbose,
    debug: options.debug,
    timeout: options.timeout,
    autoStart: !!command, // Auto-start whenever we have a command
    fallbackToStateless: !daemonOnly // No fallback if daemon-only mode
  });
  try {
    const result = await daemonClient.listTools();
    return { 
      tools: result.tools || [], 
      daemonClient,
      isDaemon: true,
      close: () => Promise.resolve()
    };
  } catch (error) {
    // If daemon-only mode (no command), don't try direct connection
    if (daemonOnly) {
      throw error;
    }
    // Fallback to direct connection
    if (options.debug) {
      console.error('[DEBUG] Daemon failed, using direct connection:', error);
    }
    const transport = new StdioClientTransport({
      command,
      args,
      stderr: (options.logs || options.verbose) ? 'inherit' : 'ignore'
    });
    const client = new Client({
      name: 'mcpli',
      version: '1.0.0'
    }, {
      capabilities: {}
    });
    try {
      await client.connect(transport);
      const result = await client.listTools();
      return { 
        tools: result.tools || [], 
        client, 
        isDaemon: false,
        close: () => client.close() 
      };
    } catch (error) {
      throw new Error(`Failed to connect to MCP server: ${error instanceof Error ? error.message : error}`);
    }
  }
}
function normalizeToolName(name: string): string {
  return name.toLowerCase().replace(/[^a-z0-9]/g, '');
}
function findTool(userArgs: string[], tools: any[]) {
  const toolMap = new Map();
  // Build tool index
  for (const tool of tools) {
    const name = tool.name;
    toolMap.set(name, tool);
    toolMap.set(name.replace(/_/g, '-'), tool);
    toolMap.set(normalizeToolName(name), tool);
  }
  // Look for tool selection - first non-option argument is the tool name
  for (const arg of userArgs) {
    if (!arg.startsWith('--') && !arg.startsWith('-')) {
      if (toolMap.has(arg)) {
        return { tool: toolMap.get(arg), toolName: arg };
      }
    }
  }
  return null;
}
function parseParams(userArgs: string[], selectedTool: any, toolName: string): Record<string, any> {
  const params: Record<string, any> = {};
  const schema = selectedTool.inputSchema?.properties || {};
  // Find the start of parameters for the selected tool
  const toolNameIndex = userArgs.indexOf(toolName);
  if (toolNameIndex === -1) {
    // This should not happen if findTool worked correctly, but as a safeguard.
    return {};
  }
  const paramArgs = userArgs.slice(toolNameIndex + 1);
  const args: { key: string, value: string | boolean }[] = [];
  // Phase 1: Tokenize arguments into a structured list of key-value pairs
  for (let i = 0; i < paramArgs.length; i++) {
    const arg = paramArgs[i];
    let key: string | undefined;
    let value: string | boolean | undefined;
    if (arg.startsWith('--')) {
      if (arg.includes('=')) {
        const parts = arg.split('=', 2);
        key = parts[0].slice(2);
        value = parts[1];
      } else {
        key = arg.slice(2);
        const nextArg = paramArgs[i + 1];
        if (nextArg && (!nextArg.startsWith('-') || !isNaN(Number(nextArg)))) {
          value = nextArg;
          i++; // Consume value argument
        } else {
          value = true; // It's a boolean flag
        }
      }
    } else if (arg.startsWith('-') && arg.length === 2 && isNaN(Number(arg[1]))) {
      // Handle short-form arguments like -f (but not negative numbers like -5)
      key = arg.slice(1);
      const nextArg = paramArgs[i + 1];
      if (nextArg && (!nextArg.startsWith('-') || !isNaN(Number(nextArg)))) {
        value = nextArg;
        i++; // Consume value argument
      } else {
        value = true; // It's a boolean flag
      }
    }
    if (key !== undefined && value !== undefined) {
      args.push({ key, value });
    }
    // Non-option arguments (positional) are ignored for now
  }
  // Phase 2: Parse and convert values based on the tool's inputSchema
  for (const { key, value } of args) {
    const propSchema = schema[key];
    if (!propSchema) {
      // If no schema is found for this param, make a best effort to parse
      if (value === true) {
        params[key] = true;
      } else {
        try {
          params[key] = JSON.parse(value as string);
        } catch {
          params[key] = value;
        }
      }
      continue;
    }
    // Handle boolean type specifically, as it can be a flag or have a value
    if (propSchema.type === 'boolean') {
      if (value === true) {
        params[key] = true;
        continue;
      }
      const strValue = String(value).toLowerCase();
      if (strValue === 'true') {
        params[key] = true;
      } else if (strValue === 'false') {
        params[key] = false;
      } else {
        throw new Error(`Argument --${key} expects a boolean (true/false), but received "${value}".`);
      }
      continue;
    }
    // For all other types, a valueless flag is an error
    if (value === true) {
      throw new Error(`Argument --${key} of type "${propSchema.type}" requires a value.`);
    }
    const strValue = value as string;
    switch (propSchema.type) {
      case 'string':
        params[key] = strValue;
        break;
      case 'number':
      case 'integer':
        const num = Number(strValue);
        if (isNaN(num) || strValue.trim() === '') {
          throw new Error(`Argument --${key} expects a ${propSchema.type}, but received "${strValue}".`);
        }
        if (propSchema.type === 'integer' && !Number.isInteger(num)) {
          throw new Error(`Argument --${key} expects an integer, but received "${strValue}".`);
        }
        params[key] = num;
        break;
      case 'array':
      case 'object':
        try {
          params[key] = JSON.parse(strValue);
        } catch (e) {
          throw new Error(`Argument --${key} expects a valid JSON ${propSchema.type}. Parse error: ${e instanceof Error ? e.message : String(e)} on input: "${strValue}"`);
        }
        break;
      case 'null':
        if (strValue.toLowerCase() !== 'null') {
          throw new Error(`Argument --${key} expects null, but received "${strValue}".`);
        }
        params[key] = null;
        break;
      default:
        // Fallback for schemas with anyOf, oneOf, or no type property.
        try {
          params[key] = JSON.parse(strValue);
        } catch {
          params[key] = strValue;
        }
    }
  }
  return params;
}
function extractContent(result: any): any {
  if (!result.content || result.content.length === 0) {
    return null;
  }
  if (result.content.length === 1) {
    const item = result.content[0];
    if (item.type === 'text') {
      try {
        return JSON.parse(item.text);
      } catch {
        return item.text;
      }
    }
    return item;
  }
  return result.content.map((item: any) => {
    if (item.type === 'text') {
      try {
        return JSON.parse(item.text);
      } catch {
        return item.text;
      }
    }
    return item;
  });
}
function printToolHelp(tool: any) {
  console.log(`MCPLI Tool: ${tool.name}`);
  console.log('');
  if (tool.description) {
    console.log(`Description: ${tool.description}`);
    console.log('');
  }
  console.log(`Usage: mcpli ${tool.name} [options] -- <mcp-server-command> [args...]`);
  console.log('');
  if (tool.inputSchema && tool.inputSchema.properties) {
    console.log('Options:');
    const properties = tool.inputSchema.properties;
    const required = tool.inputSchema.required || [];
    for (const [propName, propSchema] of Object.entries(properties)) {
      const schema = propSchema as any;
      const isRequired = required.includes(propName);
      const type = schema.type || 'string';
      const description = schema.description || '';
      const defaultValue = schema.default;
      let line = `  --${propName.padEnd(20)}`;
      if (type) line += ` (${type})`;
      if (isRequired) line += ' [required]';
      if (description) line += ` ${description}`;
      if (defaultValue !== undefined) line += ` (default: ${JSON.stringify(defaultValue)})`;
      console.log(line);
    }
    console.log('');
  }
  console.log('Examples:');
  const exampleName = tool.name.replace(/_/g, '-');
  console.log(`  mcpli ${exampleName} --help -- node server.js`);
  if (tool.inputSchema && tool.inputSchema.properties) {
    const properties = Object.keys(tool.inputSchema.properties);
    if (properties.length > 0) {
      const firstProp = properties[0];
      console.log(`  mcpli ${exampleName} --${firstProp} "example-value" -- node server.js`);
    }
  }
}
function printHelp(tools: any[], specificTool?: any) {
  if (specificTool) {
    printToolHelp(specificTool);
    return;
  }
  console.log('MCPLI - Turn any MCP server into a first-class CLI tool');
  console.log('');
  console.log('Usage:');
  console.log('  mcpli <tool> [tool-options...] -- <mcp-server-command> [args...]');
  console.log('  mcpli <tool> --help -- <mcp-server-command> [args...]');
  console.log('  mcpli --help -- <mcp-server-command> [args...]');
  console.log('  mcpli daemon <subcommand> [options]');
  console.log('');
  console.log('Global Options:');
  console.log('  --help, -h     Show this help and list all available tools');
  console.log('  --verbose      Show MCP server output (stderr/logs)');
  console.log('  --raw          Print raw MCP response');
  console.log('  --debug        Enable debug output');
  console.log('  --timeout=<ms> Set daemon timeout (default: 30000)');
  console.log('');
  console.log('Daemon Commands:');
  console.log('  daemon start   Start long-lived daemon process');
  console.log('  daemon stop    Stop daemon process');
  console.log('  daemon status  Show daemon status');
  console.log('  daemon restart Restart daemon process');
  console.log('  daemon logs    Show daemon logs');
  console.log('  daemon clean   Clean up daemon files');
  console.log('');
  if (tools.length > 0) {
    console.log('Available Tools:');
    for (const tool of tools) {
      const name = tool.name.replace(/_/g, '-');
      const desc = tool.description || 'No description';
      console.log(`  ${name.padEnd(20)} ${desc.slice(0, 60)}${desc.length > 60 ? '...' : ''}`);
    }
    console.log('');
    console.log('Tool Help:');
    console.log(`  mcpli <tool> --help -- <mcp-server-command>    Show detailed help for specific tool`);
    console.log('');
    console.log('Examples:');
    console.log(`  mcpli ${tools[0].name.replace(/_/g, '-')} --help -- node server.js`);
    console.log(`  mcpli ${tools[0].name.replace(/_/g, '-')} --option value -- node server.js`);
    console.log('');
    console.log('Fast Execution (via auto-daemon):');
    console.log(`  mcpli ${tools[0].name.replace(/_/g, '-')} --option value  # No MCP server command needed after first use`);
  } else {
    console.log('No tools found. The MCP server may not be responding correctly.');
    console.log('');
    console.log('Examples:');
    console.log('  mcpli --help -- node server.js       # Show tools from server.js');
    console.log('  mcpli daemon start -- node server.js # Start long-lived daemon');
  }
}
async function main() {
  try {
    const result = parseArgs(process.argv);
    const { globals } = result;
    if (globals.debug) {
      console.error('[DEBUG] Parsed args:', result);
    }
    // Handle daemon subcommands
    if (globals.daemon) {
      const { daemonCommand, daemonArgs } = result as any;
      if (globals.help || !daemonCommand) {
        printDaemonHelp();
        return;
      }
      const options = {
        debug: globals.debug,
        logs: globals.logs || globals.verbose,
        force: globals.force,
        timeout: globals.timeout
      };
      switch (daemonCommand) {
        case 'start':
          const dashIndex = daemonArgs.indexOf('--');
          if (dashIndex === -1) {
            console.error('Error: Command required after -- for daemon start');
            console.error('Usage: mcpli daemon start -- <command> [args...]');
            process.exit(1);
          }
          const command = daemonArgs[dashIndex + 1];
          const args = daemonArgs.slice(dashIndex + 2);
          if (!command) {
            console.error('Error: Command required after --');
            process.exit(1);
          }
          await handleDaemonStart(command, args, options);
          break;
        case 'stop':
          const stopDashIndex = daemonArgs.indexOf('--');
          if (stopDashIndex !== -1) {
            const stopCommand = daemonArgs[stopDashIndex + 1];
            const stopArgs = daemonArgs.slice(stopDashIndex + 2);
            await handleDaemonStop(stopCommand, stopArgs, options);
          } else {
            await handleDaemonStop(undefined, [], options);
          }
          break;
        case 'status':
          await handleDaemonStatus(options);
          break;
        case 'restart':
          const restartDashIndex = daemonArgs.indexOf('--');
          if (restartDashIndex !== -1) {
            const restartCommand = daemonArgs[restartDashIndex + 1];
            const restartArgs = daemonArgs.slice(restartDashIndex + 2);
            await handleDaemonRestart(restartCommand, restartArgs, options);
          } else {
            await handleDaemonRestart(undefined, [], options);
          }
          break;
        case 'logs':
          await handleDaemonLogs(options);
          break;
        case 'clean':
          await handleDaemonClean(options);
          break;
        default:
          console.error(`Error: Unknown daemon command: ${daemonCommand}`);
          console.error('Use "mcpli daemon --help" to see available commands');
          process.exit(1);
      }
      return;
    }
    // Regular tool execution mode
    const { childCommand, childArgs, userArgs } = result;
    // No error for missing childCommand - we'll try daemon mode first
    // Show help for regular mode
    if (globals.help) {
      if (childCommand) {
        // Get tools to show in help - always discover tools for root help
        try {
          const { tools, close } = await discoverTools(childCommand, childArgs, globals);
          printHelp(tools);
          await close();
        } catch (error) {
          console.error(`Error connecting to MCP server: ${error instanceof Error ? error.message : error}`);
          console.error('Cannot show available tools. Please check your MCP server command.');
          printHelp([]);
        }
      } else {
        // Try daemon mode for help - discover tools from running daemon
        try {
          const { tools, close } = await discoverTools('', [], globals);
          printHelp(tools);
          await close();
        } catch (error) {
          console.error('Error: No daemon running and MCP server command not provided');
          console.error('Usage: mcpli --help -- <mcp-server-command> [args...]');
          console.error('Example: mcpli --help -- node server.js');
          printHelp([]);
        }
      }
      return;
    }
    if (globals.debug) {
      console.error('[DEBUG] Tool execution mode:', { childCommand, childArgs, userArgs });
    }
    // Discover tools
    const { tools, client, daemonClient, isDaemon, close } = await discoverTools(childCommand, childArgs, globals);
    if (globals.debug) {
      console.error('[DEBUG] Found tools:', tools.map((t: any) => t.name));
      console.error('[DEBUG] Using daemon:', isDaemon);
    }
    // Show help if no tool specified
    if (userArgs.length === 0) {
      printHelp(tools);
      await close();
      return;
    }
    // Find selected tool
    const toolResult = findTool(userArgs, tools);
    if (!toolResult) {
      console.error('Error: No tool specified or tool not found');
      console.error('Available tools:', tools.map((t: any) => t.name.replace(/_/g, '-')).join(', '));
      console.error('Use --help to see all available tools');
      await close();
      process.exit(1);
    }
    const { tool: selectedTool, toolName } = toolResult;
    // Check for tool-specific help
    const hasHelp = userArgs.some((arg: string) => arg === '--help' || arg === '-h');
    if (hasHelp) {
      printHelp(tools, selectedTool);
      await close();
      return;
    }
    if (globals.debug) {
      console.error('[DEBUG] Selected tool:', selectedTool.name);
      console.error('[DEBUG] Tool name used:', toolName);
    }
    // Parse parameters
    const params = parseParams(userArgs, selectedTool, toolName);
    if (globals.debug) {
      console.error('[DEBUG] Parameters:', params);
    }
    // Execute tool using appropriate client
    let executionResult;
    if (isDaemon && daemonClient) {
      executionResult = await daemonClient.callTool({
        name: selectedTool.name,
        arguments: params
      });
    } else if (client) {
      executionResult = await client.callTool({
        name: selectedTool.name,
        arguments: params
      });
    } else {
      throw new Error('No client available for tool execution');
    }
    await close();
    // Output result
    if (globals.raw) {
      console.log(JSON.stringify(executionResult, null, 2));
    } else {
      const extracted = extractContent(executionResult);
      if (extracted !== null) {
        if (typeof extracted === 'string') {
          console.log(extracted);
        } else {
          console.log(JSON.stringify(extracted, null, 2));
        }
      }
    }
  } catch (error) {
    console.error(`Error: ${error instanceof Error ? error.message : error}`);
    process.exit(1);
  }
}
main();
</file>

</files>
